<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Satellite Footprint Map</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            background-color: #0d1117;
            color: #c9d1d9;
            overflow: hidden;
        }

        .leaflet-control-zoom,
        .leaflet-control-attribution {
            display: none !important;
        }
        .sat-label {
            color: #ffffff;
            font-size: 14px;
            font-family: 'Segoe UI', sans-serif;
            font-weight: normal;
            text-align: center;
            white-space: nowrap;
            pointer-events: none;
        }
    </style>
</head>
<body>
<div class="d-flex justify-content-center align-items-center" style="height: 100vh; overflow: hidden;">
    <div id="footprintmap" style="width: 1024px; height: 512px;"></div>
</div>


<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
    const EARTH_RADIUS_KM = 6371;
    const FOOTPRINT_SEGMENTS = 180;
    const FOOTPRINT_FILL_COLOR = '#ffd502';
    const FOOTPRINT_FILL_OPACITY = 0.3;

    const map = L.map('footprintmap', {
        zoomControl: false,
        attributionControl: false,
        dragging: false,
        scrollWheelZoom: false,
        doubleClickZoom: false,
        boxZoom: false,
        keyboard: false,
        zoomSnap: 0,          // optional, for smoother lock
        inertia: false,       // disables momentum
        minZoom: 2,
        maxZoom: 2,
        worldCopyJump: false,

    }).setView([0, 0], 2);

    // ✅ Limit map bounds to avoid duplicate wrap-around
    map.setMaxBounds([
        [-90, -180],
        [90, 180]
    ]);    // Use your original working tile source
    L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/' +
        'World_Imagery/MapServer/tile/{z}/{y}/{x}', {
        attribution: 'Tiles © Esri',
        noWrap: true
    }).addTo(map);

    function computeFootprintRadiusKm(altitudeKm) {
        const theta = Math.acos(EARTH_RADIUS_KM / (EARTH_RADIUS_KM + altitudeKm));
        return EARTH_RADIUS_KM * theta;
    }

    function generateFootprintCircle(lat, lon, radiusKm, segments) {
        const points = [];
        const rad = Math.PI / 180;
        const deg = 180 / Math.PI;

        for (let i = 0; i < segments; i++) {
            const angle = (360 / segments) * i * rad;

            const lat1 = lat * rad;
            const lon1 = lon * rad;
            const d = radiusKm / EARTH_RADIUS_KM;

            const lat2 = Math.asin(Math.sin(lat1) * Math.cos(d) + Math.cos(lat1) * Math.sin(d) * Math.cos(angle));
            const lon2 = lon1 + Math.atan2(Math.sin(angle) * Math.sin(d) * Math.cos(lat1), Math.cos(d) - Math.sin(lat1) * Math.sin(lat2));

            points.push([lat2 * deg, lon2 * deg]);
        }
        return points;
    }

    const satLayers = {};

    function drawOrUpdateSatellite(sat) {
        const shortNameMatch = sat.name.match(/\(([^)]+)\)/);
        const shortName = shortNameMatch ? shortNameMatch[1] : sat.name;
        const key = sat.name;

        const radiusKm = computeFootprintRadiusKm(sat.altitude);
        const footprintPoints = generateFootprintCircle(sat.sublat, sat.sublon, radiusKm, FOOTPRINT_SEGMENTS);

        const charWidth = 7;
        const padding = 10;
        const iconWidth = shortName.length * charWidth + padding;

        if (satLayers[key]) {
            // Update existing
            satLayers[key].footprint.setLatLngs(footprintPoints);
            satLayers[key].marker.setLatLng([sat.sublat, sat.sublon]);
            satLayers[key].label.setLatLng([sat.sublat, sat.sublon]);
        } else {
            // Create new
            const footprint = L.polygon(footprintPoints, {
                color: FOOTPRINT_FILL_COLOR,
                fillColor: FOOTPRINT_FILL_COLOR,
                fillOpacity: FOOTPRINT_FILL_OPACITY,
                weight: 1
            }).addTo(map);

            const marker = L.circleMarker([sat.sublat, sat.sublon], {
                radius: 4,
                color: '#ff0202',
                weight: 1,
                fillColor: '#f6cb3e',
                fillOpacity: 1
            }).addTo(map);

            const label = L.marker([sat.sublat, sat.sublon], {
                icon: L.divIcon({
                    className: 'sat-label',
                    html: shortName,
                    iconSize: [iconWidth, 20],
                    iconAnchor: [iconWidth / 2, 25]
                })
            }).addTo(map);

            satLayers[key] = { footprint, marker, label };
        }
    }

    function updateSatellites() {
        fetch('http://esp32azel.local/satellites')
            .then(response => response.json())
            .then(data => {
                data.forEach(drawOrUpdateSatellite);
            })
            .catch(error => {
                console.error("Failed to fetch satellite data:", error);
            });
    }

    updateSatellites(); // Initial call
    setInterval(updateSatellites, 2500); // Refresh every 5 seconds
</script>




</body>
</html>
