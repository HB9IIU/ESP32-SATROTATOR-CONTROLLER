<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8"/>
        <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
        <title>Satellite Tracker</title>
        <link href="favicon.ico" rel="icon" type="image/x-icon">
        <!-- ‚úÖ Bootstrap 5 CSS -->
        <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
        <!-- Highcharts and dependencies -->
        <script src="https://code.highcharts.com/highcharts.js"></script>
        <script src="https://unpkg.com/suncalc@1.9.0/suncalc.js"></script>
        <script src="https://code.highcharts.com/highcharts-more.js"></script>
        <link href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" rel="stylesheet"/>
        <style>/* üåë Global Layout */body { font-family: Arial, sans-serif; background-color: #0d1117; color: #c9d1d9; margin: 0; padding: 1rem; } /* üîò Radio Buttons */input[type="radio"] { appearance: none; -webkit-appearance: none; width: 20px; height: 20px; border: 3px solid #f6cb3e; border-radius: 50%; background-color: transparent; outline: none; cursor: pointer; margin: 0.5rem; display: flex; align-items: center; justify-content: center; } input[type="radio"]::before { content: ""; width: 10px; height: 10px; border-radius: 50%; background-color: transparent; transition: background-color 0.2s ease; } input[type="radio"]:checked::before { background-color: #f6cb3e; } /* üß≠ Map Container */#map { width: 400px; height: 400px; border: 2px solid #989797; } /* üí≥ Card Layout */.card { background-color: #161b22; padding: 0.5rem; margin: 0.3rem; border-radius: 0.4rem; box-shadow: 0 0 6px rgba(0, 0, 0, 0.3); min-width: 180px; max-width: 100%; flex: 1; } /* üìã Label Styling */.label { font-weight: bold; color: #f6cb3e; margin-bottom: 0.5rem; } /* üîò Radio Alignment */.radio { float: right; } /* üî¶ Highlight Banner */.highlight { background-color: #161b22; margin-top: 1rem; padding: 1rem; font-size: 1.5rem; text-align: center; color: #f6cb3e; border-radius: 0.5rem; border: 2px solid #30363d; } /* üõ∞Ô∏è Elevation Highlight */tr.above-horizon td { color: #00ff88 !important;  /* Green */ font-weight: bold; } tr.near-event td { color: #f6cb3e !important;  /* Yellow */ font-weight: bold; } /* üîï Hidden Elements */.hidden { display: none; } /* üåï Moon Image */#moonImage { transform: rotate(180deg); width: 195px; height: 195px; object-fit: cover; border-radius: 0.5rem; margin: auto; } .moon-image { display: flex; align-items: stretch; justify-content: center; padding: 0; } /* ‚òÄÔ∏è Sun Chart */#sunChart { height: 240px; width: 100%; margin: 0 auto; } /* üì° Polar Plot */#polarPlot { width: 100%; margin: 0 auto; background-color: #222;  /* Just for debugging */ transition: opacity 0.5s ease; } /* üìç Polar Legend */#polarLegend { text-align: center; margin-top: 0.5rem; transition: opacity 0.5s ease; } /* üìä Table Cell Alignment */table th, table td { text-align: center; }</style>
        <style>.leaflet-control-zoom, .leaflet-control-attribution { display: none !important; } .sat-label { color: #ffffff; font-size: 14px; font-family: 'Segoe UI', sans-serif; font-weight: normal; text-align: center; white-space: nowrap; pointer-events: none; }</style>
    </head>
    <body>
        <div class="container-fluid">
            <!-- Header Row -->
            <div class="row" data-pg-collapsed>
                <div class="col-md-4 d-flex align-items-center">
                    <h3 class="text-start text-warning" id="localTime">Local: --:--:--</h3>
                </div>
                <div class="col-md-4 d-flex align-items-center justify-content-center" data-pg-collapsed>
                    <h1 class="m-0 text-center text-warning">HB9IIU SatAlign</h1>
                </div>
                <div class="col-md-4 d-flex align-items-center justify-content-end" data-pg-collapsed>
                    <h3 class="text-end text-warning" id="utcTime">UTC: --:--:--</h3>
                </div>
            </div>
            <!-- Satellite Table -->
            <div class="table-responsive mb-4" data-pg-collapsed>
                <table class="table table-dark table-bordered align-middle" id="satTable">
                    <thead class="table-light">
                        <tr class="table-dark">
                            <th>Select</th>
                            <th>Name</th>
                            <th>Azimuth</th>
                            <th>Elevation</th>
                            <th>Freq (MHz)</th>
                            <th>Corrected Freq</th>
                            <th>AOS</th>
                            <th>TCA</th>
                            <th>LOS</th>
                            <th>Max El</th>
                            <th>Duration</th>
                            <th>Next Event</th>
                        </tr>
                    </thead>
                    <tbody id="satBody"></tbody>
                </table>
            </div>
            <!-- Section for Sun/Moon cards and chart -->
            <div class="row g-3 mb-4">
                <div class="col-md-3">
                    <div id="sunChart"></div>
                </div>
                <div class="col-md-3" data-pg-collapsed>
                    <div class="card p-2">
                        <div class="radio">
                            <input name="trackingTarget" type="radio" value="sun">
                        </div>
                        <div class="label" style="font-size: 20px;">üåû Sun</div>
                        <table class="table table-sm table-borderless text-light">
                            <tr>
                                <td class="table-dark" style="text-align: left; padding-left: 15px;">Azimuth:</td>
                                <td class="table-dark" id="sunAz">--¬∞</td>
                            </tr>
                            <tr>
                                <td class="table-dark" style="text-align: left; padding-left: 15px;">Elevation:</td>
                                <td class="table-dark" id="sunEl">--¬∞</td>
                            </tr>
                            <tr>
                                <td class="table-dark" style="text-align: left; padding-left: 15px;">Sunrise:</td>
                                <td class="table-dark" id="sunrise">--:--</td>
                            </tr>
                            <tr>
                                <td class="table-dark" style="text-align: left; padding-left: 15px;">Sunset:</td>
                                <td class="table-dark" id="sunset">--:--</td>
                            </tr>
                        </table>
                    </div>
                </div>
                <div class="col-md-3" data-pg-collapsed>
                    <div class="card p-2">
                        <div class="radio">
                            <input name="trackingTarget" type="radio" value="moon">
                        </div>
                        <div class="label" style="font-size: 20px;">üåô Moon</div>
                        <table class="table table-sm table-borderless text-light">
                            <tr>
                                <td class="table-dark" style="text-align: left; padding-left: 15px;">Azimuth:</td>
                                <td class="table-dark" id="moonAz">--¬∞</td>
                            </tr>
                            <tr>
                                <td class="table-dark" style="text-align: left; padding-left: 15px;">Elevation:</td>
                                <td class="table-dark" id="moonEl">--¬∞</td>
                            </tr>
                            <tr>
                                <td class="table-dark" style="text-align: left; padding-left: 15px;">Moonrise:</td>
                                <td class="table-dark" id="moonrise">--:--</td>
                            </tr>
                            <tr>
                                <td class="table-dark" style="text-align: left; padding-left: 15px;">Moonset:</td>
                                <td class="table-dark" id="moonset">--:--</td>
                            </tr>
                        </table>
                    </div>
                </div>
                <div class="col-md-3" data-pg-collapsed>
                    <div class="card moon-image">
                        <img alt="NASA Moon of the Hour" id="moonImage" src="">
                    </div>
                </div>
            </div>
            <!-- Tracking Banner -->
            <div class="highlight" id="trackingBanner">üì° Currently Tracking:</div>
            <!-- Stop Tracking Section -->
            <div class="hidden mt-4 text-center" id="stopTrackingWrapper">
                <button class="btn btn-danger btn-lg mb-3" id="stopTrackingBtn">Stop Tracking</button>
                <div class="row">
                    <div class="col-md-6 d-flex justify-content-center">
                        <div id="map"></div>
                    </div>
                    <div class="col-md-6">
                        <div id="polarPlot"></div>
                        <div class="mt-2 text-center text-light" id="polarLegend">
                            <span style="color: #00ff00;">‚óè
                            AOS</span>
                            <span style="color: #f6cb3e;"> ‚óè TCA</span>
                            <span style="color: #ff3333;"> ‚óè
                            LOS</span>
                        </div>
                    </div>
                </div>
                <div class="row justify-content-center">
</div>
                <div class="mt-3 fs-5 text-warning" id="rotorStatus">
                    Rotor Position ‚Äî Azimuth: <span id="rotorAz">--</span>¬∞, Elevation: <span id="rotorEl">--</span>¬∞
                </div>
            </div>
            <div class="row">
                <div class="col-md-12">
                    <div class="d-flex justify-content-center">
                        <div id="footprintmap" style="width: 1024px; height: 512px;"></div>
                    </div>
                </div>
            </div>
        </div>
        <!-- Scripts remain below -->
        <script>
    var latitude = 46.4668;
    var longitude = 6.8616;


    let selectedTarget = null;
    const banner = document.getElementById("trackingBanner");
    const stopWrapper = document.getElementById("stopTrackingWrapper");

    const websocket = new WebSocket("ws://" + location.hostname + ":81");

    websocket.onopen = () => {
        if (selectedTarget) websocket.send(JSON.stringify({track: selectedTarget}));
    };


    websocket.onmessage = event => {
        try {
            const data = JSON.parse(event.data);

            // üîÅ Rotor feedback from ESP32
            if (data.type === "rotor" && data.azi !== undefined && data.ele !== undefined) {
                console.log("üîÑ Rotor update received:", data);

                // Update yellow direction line on the map
                if (map && directionLine) {
                    const observer = {lat: latitude, lng: longitude};
                    const target = computeTargetPoint(observer.lat, observer.lng, data.azi, 2);
                    directionLine.setPath([observer, target]);
                }

                // Update displayed rotor values
                document.getElementById("rotorAz").textContent = data.azi.toFixed(1);
                document.getElementById("rotorEl").textContent = data.ele.toFixed(1);
                console.log(`üìü Displayed rotor azimuth: ${data.azi.toFixed(1)}¬∞, elevation: ${data.ele.toFixed(1)}¬∞`);
                return;
            }

            // üõ∞Ô∏è Satellite prediction update
            if (!data.name || data.az === undefined || data.el === undefined) return;

            // Auto-select if nothing is currently selected
            if (!selectedTarget) {
                selectedTarget = data.name;

                const radioToCheck = document.querySelector(`input[name="trackingTarget"][value="${selectedTarget.toLowerCase()}"]`);
                if (radioToCheck) radioToCheck.checked = true;

                banner.innerHTML = `üì° Currently Tracking: ${selectedTarget} ‚Äî Az: ${data.az.toFixed(1)}¬∞, El: ${data.el.toFixed(1)}¬∞`;
                stopWrapper.classList.remove("hidden");
                console.log(`üõ∞Ô∏è Now tracking: ${selectedTarget}`);
                return;
            }

            // Regular update for the selected target
            if (data.name.toLowerCase() === selectedTarget.toLowerCase()) {
                banner.innerHTML = `üì° Currently Tracking: ${data.name} ‚Äî Az: ${data.az.toFixed(1)}¬∞, El: ${data.el.toFixed(1)}¬∞`;
                stopWrapper.classList.remove("hidden");
                console.log(`üîÅ Tracking update: ${data.name}, Az: ${data.az.toFixed(1)}¬∞, El: ${data.el.toFixed(1)}¬∞`);

                // üåç Update live position marker on polar plot
                const chart = Highcharts.charts.find(c => c && c.renderTo.id === 'polarPlot');
                if (chart) {
                    const liveSeries = chart.get('liveMarker');
                    if (liveSeries) {
                        if (data.el > 0) {
                            liveSeries.setData([{x: data.az, y: data.el}], true);
                        } else {
                            liveSeries.setData([], true); // hide if below horizon
                        }
                    }
                }
            }

        } catch (e) {
            console.warn("‚ùó Invalid WebSocket message:", event.data);
        }
    };


    websocket.onclose = () => {
        setTimeout(() => location.reload(), 2000);
    };

    document.body.addEventListener("change", (e) => {
        if (e.target.name === "trackingTarget") {
            selectedTarget = e.target.value;
            fetch("/track", {
                method: "POST",
                headers: {"Content-Type": "application/json"},
                body: JSON.stringify({target: selectedTarget})
            }).then(res => {
                if (res.ok) {
                    banner.innerHTML = `üì° Currently Tracking: ${selectedTarget}`;
                    stopWrapper.classList.remove("hidden");

                    const plot = document.getElementById("polarPlot");
                    const legend = document.getElementById("polarLegend");

                    if (selectedTarget === "sun" || selectedTarget === "moon") {
                        plot.style.display = "none";
                        legend.style.display = "none";
                    } else {
                        plot.style.display = "block";
                        legend.style.display = "block";
                        loadAndDrawPolarPlot();
                    }
                }
            });
        }
    });

    document.getElementById("stopTrackingBtn").addEventListener("click", () => {
        selectedTarget = null;
        document.querySelectorAll('input[name="trackingTarget"]').forEach(r => r.checked = false);
        fetch("/track", {
            method: "POST",
            headers: {"Content-Type": "application/json"},
            body: JSON.stringify({target: ""})
        }).then(res => {
            if (res.ok) {
                banner.innerHTML = "üì° Currently Tracking: --";
                stopWrapper.classList.add("hidden");

            }
        });
    });


    async function loadSunMoonData() {
        const res = await fetch("/sunmoon");
        const data = await res.json();
        document.getElementById("sunAz").textContent = `${data.sunAzimuth.toFixed(1)}¬∞`;
        document.getElementById("sunEl").textContent = `${data.sunElevation.toFixed(1)}¬∞`;
        document.getElementById("sunrise").textContent = data.sunRiseLocal;
        document.getElementById("sunset").textContent = data.sunSetLocal;
        document.getElementById("moonAz").textContent = `${data.moonAzimuth.toFixed(1)}¬∞`;
        document.getElementById("moonEl").textContent = `${data.moonElevation.toFixed(1)}¬∞`;
        document.getElementById("moonrise").textContent = data.moonRiseLocal;
        document.getElementById("moonset").textContent = data.moonSetLocal;
    }

    async function loadSatelliteData() {
        const res = await fetch("/satellites");
        const data = await res.json();
        const tbody = document.getElementById("satBody");
        tbody.innerHTML = "";

        data.forEach(sat => {
            const row = document.createElement("tr");

            if (sat.elevation > 10) {
                row.classList.add("above-horizon"); // üü¢ Green
            } else if (sat.elevation > 0) {
                row.classList.add("near-event");    // üü° Yellow
            }

            row.innerHTML = `
  <td><input type="radio" name="trackingTarget" value="${sat.name}"></td>
  <td class="left">${sat.name}</td>
  <td>${sat.azimuth.toFixed(1)}¬∞</td>
  <td>${sat.elevation.toFixed(1)}¬∞</td>
  <td>${sat.frequencyMHz.toFixed(3)}</td>
  <td>${sat.correctedFreqMHz.toFixed(3)}</td>
  <td>${sat.aosLocal}</td>
  <td>${sat.tcaLocal}</td>
  <td>${sat.losLocal}</td>
  <td>${sat.maxElevation.toFixed(1)}</td>
  <td>${sat.passDuration}</td>
  <td>${sat.timeToEvent}</td>
`;

            tbody.appendChild(row);
        });


        if (selectedTarget) {
            const radioToCheck = document.querySelector(`input[name="trackingTarget"][value="${selectedTarget}"]`);
            if (radioToCheck) radioToCheck.checked = true;
        }
    }


    function updateClocks() {
        const now = new Date();
        const utcStr = now.toUTCString().split(" ")[4];
        const localStr = now.toLocaleTimeString('en-GB', {hour12: false});
        document.getElementById("utcTime").textContent = `UTC: ${utcStr}`;
        document.getElementById("localTime").textContent = `Local: ${localStr}`;
    }

    function getHourOfYearUTC() {
        const now = new Date();
        const startOfYear = new Date(Date.UTC(now.getUTCFullYear(), 0, 1));
        const diffMs = now - startOfYear;
        return Math.floor(diffMs / (1000 * 60 * 60));
    }

    const hourNumber = getHourOfYearUTC().toString().padStart(4, '0');
    const moonBaseUrl = 'https://svs.gsfc.nasa.gov/vis/a000000/a005400/a005416/frames/216x216_1x1_30p/';
    document.getElementById('moonImage').src = moonBaseUrl + `moon.${hourNumber}.jpg`;

    function buildSunChartOLD() {

        const now = new Date();
        const decimal = d => d.getHours() + d.getMinutes() / 60 + d.getSeconds() / 3600;
        const sunPos = h => SunCalc.getPosition(new Date(now.setHours(0, 0, 0, 0) + h * 3600 * 1000), latitude, longitude).altitude * 180 / Math.PI;

        const sunData = [];
        const times = SunCalc.getTimes(new Date(), latitude, longitude);
        const sunrise = decimal(times.sunrise), sunset = decimal(times.sunset), transit = decimal(times.solarNoon);
        const transitElevation = sunPos(transit);
        for (let h = sunrise - 1; h <= sunset + 1; h += 0.25) sunData.push([h, sunPos(h)]);

        const chart = Highcharts.chart('sunChart', {
            chart: {
                type: 'spline',
                backgroundColor: '#0d1117'
            },
            accessibility: {
                enabled: false
            },
            title: null,
            xAxis: {
                title: {text: 'Time (Hours)', style: {color: '#c9d1d9'}},
                labels: {style: {color: '#c9d1d9'}},
                min: sunrise - 1,
                max: sunset + 1
            },
            yAxis: {
                title: {text: 'Elevation (¬∞)', style: {color: '#c9d1d9'}},
                labels: {style: {color: '#c9d1d9'}},
                min: 0,
                max: 90,
                plotBands: [{
                    from: 0,
                    to: 90,
                    color: 'rgba(255, 215, 0, 0.1)'
                }]
            },
            legend: {enabled: false},
            credits: {enabled: false},
            tooltip: {
                useHTML: true,
                formatter: function () {
                    const now = this.x;
                    const timeToSunset = Math.max(0, sunset - now);
                    const h = Math.floor(timeToSunset);
                    const m = Math.floor((timeToSunset - h) * 60);
                    return `
<b>‚òÄÔ∏è Current Sun</b><br>
Elevation: <b>${this.y.toFixed(1)}¬∞</b><br>
Time: <b>${formatTime(this.x)}</b><br>
Time until sunset: <b>${h}h ${m}m</b>
`;
                },
                backgroundColor: '#161b22',
                borderColor: '#ffa500',
                style: {
                    color: '#ffd700',
                    fontSize: '14px'
                }
            },


            series: [
                {
                    name: 'Sun',
                    data: sunData,
                    color: '#f6cb3e',
                    marker: {enabled: false}
                },
                {
                    type: 'scatter',
                    id: 'sunMarker',
                    data: [{
                        x: decimal(new Date()),
                        y: SunCalc.getPosition(new Date(), latitude, longitude).altitude * 180 / Math.PI
                    }],
                    marker: {enabled: false},
                    dataLabels: {
                        enabled: true,
                        useHTML: true,
                        formatter: function () {
                            return '‚òÄÔ∏è';
                        },
                        style: {
                            fontSize: '24px'
                        },
                        align: 'center',
                        verticalAlign: 'middle',
                        y: 0
                    }
                },
                {
                    type: 'scatter',
                    name: 'Transit Time',
                    data: [{
                        x: transit,
                        y: transitElevation
                    }],
                    marker: {
                        enabled: true,
                        radius: 4,
                        fillColor: '#ffa500'
                    },
                    dataLabels: {
                        enabled: true,
                        formatter: function () {
                            return formatTime(this.x);
                        },
                        style: {
                            color: '#ffa500',
                            fontWeight: 'bold',
                            fontSize: '14px'
                        },
                        align: 'center',
                        verticalAlign: 'top',
                        y: -30
                    }
                }
            ]


        });


        setInterval(() => {
            const now = new Date();
            const h = now.getHours() + now.getMinutes() / 60 + now.getSeconds() / 3600;
            const el = SunCalc.getPosition(now, latitude, longitude).altitude * 180 / Math.PI;
            chart.get('sunMarker').setData([{x: h, y: el}]);
        }, 1000);

    }

    function buildSunChart() {
        const now = new Date();
        const decimal = d => d.getHours() + d.getMinutes() / 60 + d.getSeconds() / 3600;
        const sunPos = h => {
            const pos = SunCalc.getPosition(new Date(now.setHours(0, 0, 0, 0) + h * 3600 * 1000), latitude, longitude);
            return Math.max(0, Math.min(90, pos.altitude * 180 / Math.PI)); // Clamp to 0‚Äì90¬∞
        };

        const sunData = [];
        const times = SunCalc.getTimes(new Date(), latitude, longitude);
        const sunrise = decimal(times.sunrise);
        const sunset = decimal(times.sunset);
        const transit = decimal(times.solarNoon);
        const transitElevation = sunPos(transit);  // already clamped

        for (let h = sunrise - 1; h <= sunset + 1; h += 0.25) {
            sunData.push([h, sunPos(h)]);
        }

        console.log("üîç sunData max Y:", Math.max(...sunData.map(d => d[1]))); // Diagnostic

        const chart = Highcharts.chart('sunChart', {
            chart: {
                type: 'spline',
                backgroundColor: '#0d1117'
            },
            accessibility: {
                enabled: false
            },
            title: null,
            xAxis: {
                title: {text: 'Time (Hours)', style: {color: '#c9d1d9'}},
                labels: {
                    style: {color: '#c9d1d9'},
                    format: '{value}:00'  // shows 6:00, 8:00, etc.
                },
                min: sunrise - 1,
                max: sunset + 1,
                tickInterval: 1  // every hour
            },

            yAxis: {
                title: {text: 'Elevation (¬∞)', style: {color: '#c9d1d9'}},
                labels: {style: {color: '#c9d1d9'}},
                min: 0,
                max: 90,
                tickAmount: 7,
                startOnTick: false,
                endOnTick: false,
                plotBands: [{
                    from: 0,
                    to: 90,
                    color: 'rgba(255, 215, 0, 0.1)'
                }]
            },
            legend: {enabled: false},
            credits: {enabled: false},
            tooltip: {
                useHTML: true,
                formatter: function () {
                    const now = this.x;
                    const timeToSunset = Math.max(0, sunset - now);
                    const h = Math.floor(timeToSunset);
                    const m = Math.floor((timeToSunset - h) * 60);
                    return `
<b>‚òÄÔ∏è Current Sun</b><br>
Elevation: <b>${this.y.toFixed(1)}¬∞</b><br>
Time: <b>${formatTime(this.x)}</b><br>
Time until sunset: <b>${h}h ${m}m</b>
`;
                },
                backgroundColor: '#161b22',
                borderColor: '#ffa500',
                style: {
                    color: '#ffd700',
                    fontSize: '14px'
                }
            },
            series: [
                {
                    name: 'Sun',
                    data: sunData,
                    color: '#f6cb3e',
                    marker: {enabled: false}
                },
                {
                    type: 'scatter',
                    id: 'sunMarker',
                    data: [{
                        x: decimal(new Date()),
                        y: Math.max(0, Math.min(90, SunCalc.getPosition(new Date(), latitude, longitude).altitude * 180 / Math.PI))
                    }],
                    marker: {enabled: false},
                    dataLabels: {
                        enabled: true,
                        useHTML: true,
                        formatter: function () {
                            return '‚òÄÔ∏è';
                        },
                        style: {
                            fontSize: '24px'
                        },
                        align: 'center',
                        verticalAlign: 'middle',
                        y: 0
                    }
                },
                {
                    type: 'scatter',
                    name: 'Transit Time',
                    data: [{
                        x: transit,
                        y: transitElevation
                    }],
                    marker: {
                        enabled: true,
                        radius: 4,
                        fillColor: '#ffa500'
                    },
                    dataLabels: {
                        enabled: true,
                        formatter: function () {
                            return formatTime(this.x);
                        },
                        style: {
                            color: '#ffa500',
                            fontWeight: 'bold',
                            fontSize: '14px'
                        },
                        align: 'center',
                        verticalAlign: 'top',
                        y: -30
                    }
                }
            ]
        });

        // Live update every second
        setInterval(() => {
            const now = new Date();
            const h = now.getHours() + now.getMinutes() / 60 + now.getSeconds() / 3600;
            const el = Math.max(0, Math.min(90, SunCalc.getPosition(now, latitude, longitude).altitude * 180 / Math.PI));
            chart.get('sunMarker').setData([{x: h, y: el}]);
        }, 1000);
    }


    function formatTime(decimalHour) {
        const hours = Math.floor(decimalHour);
        const minutes = Math.floor((decimalHour - hours) * 60);
        return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
    }


    async function loadAndDrawPolarPlot() {
        try {
            const res = await fetch('/passpath');
            const rawData = await res.json();

            const polarData = rawData.map(p => [p.az, p.el]);

            const aos = rawData[0];
            const tca = rawData[Math.floor(rawData.length / 2)];
            const los = rawData[rawData.length - 1];

            const labeledPoints = [
                {
                    x: aos.az,
                    y: aos.el,
                    marker: {
                        enabled: true,
                        radius: 6,
                        fillColor: '#00ff00'  // üü¢ AOS
                    },
                    customLabel: 'AOS'
                },
                {
                    x: tca.az,
                    y: tca.el,
                    marker: {
                        enabled: true,
                        radius: 6,
                        fillColor: '#f6cb3e'  // üü° TCA
                    },
                    customLabel: 'TCA'
                },
                {
                    x: los.az,
                    y: los.el,
                    marker: {
                        enabled: true,
                        radius: 6,
                        fillColor: '#ff3333'  // üî¥ LOS
                    },
                    customLabel: 'LOS'
                }
            ];

            Highcharts.chart('polarPlot', {
                chart: {
                    polar: true,
                    backgroundColor: '#0d1117',
                    height: 380
                },
                accessibility: {
                    enabled: false
                },
                title: {
                    text: 'Satellite Pass',
                    style: {color: '#f6cb3e'}
                },
                pane: {
                    size: '100%'
                },
                xAxis: {
                    tickInterval: 45,
                    min: 0,
                    max: 360,
                    labels: {
                        format: '{value}¬∞',
                        style: {color: '#c9d1d9'}
                    }
                },
                yAxis: {
                    min: 0,
                    max: 90,
                    reversed: true,
                    tickInterval: 15,
                    gridLineInterpolation: 'circle',
                    labels: {
                        format: '{value}¬∞',
                        style: {color: '#c9d1d9'}
                    }
                },
                tooltip: {
                    useHTML: true,
                    formatter: function () {
                        const label = this.point.customLabel || 'Trajectory';
                        return `<b>${label}</b><br>Az: <b>${this.x.toFixed(1)}¬∞</b><br>El: <b>${this.y.toFixed(1)}¬∞</b>`;
                    },
                    backgroundColor: '#161b22',
                    style: {color: '#f6cb3e'}
                },
                plotOptions: {
                    line: {
                        connectEnds: false,
                        marker: {enabled: false},
                        lineWidth: 3,
                        color: '#f6cb3e'
                    },
                    scatter: {
                        marker: {symbol: 'circle'}
                    }
                },
                series: [
                    {
                        name: 'Trajectory',
                        type: 'line',
                        data: polarData,
                        showInLegend: false
                    },
                    {
                        name: 'Markers',
                        type: 'scatter',
                        data: labeledPoints,
                        enableMouseTracking: true,
                        showInLegend: false
                    },
                    {
                        name: 'Current Position',
                        type: 'scatter',
                        id: 'liveMarker',
                        data: [],
                        marker: {
                            symbol: 'circle',
                            fillColor: '#1de6e6',
                            radius: 5
                        },
                        enableMouseTracking: false,
                        showInLegend: false
                    }
                ],
                credits: {enabled: false},
                legend: {enabled: false}
            });

        } catch (err) {
            console.error("Error plotting satellite pass:", err);
        }
    }


    let map;
    let directionLine;

    function computeTargetPoint(lat, lng, azimuth, distanceKm) {
        const R = 6371;
        const rad = Math.PI / 180;
        const deg = 180 / Math.PI;

        const az = azimuth * rad;
        const œÜ1 = lat * rad;
        const Œª1 = lng * rad;

        const œÜ2 = Math.asin(Math.sin(œÜ1) * Math.cos(distanceKm / R) +
            Math.cos(œÜ1) * Math.sin(distanceKm / R) * Math.cos(az));
        const Œª2 = Œª1 + Math.atan2(Math.sin(az) * Math.sin(distanceKm / R) * Math.cos(œÜ1),
            Math.cos(distanceKm / R) - Math.sin(œÜ1) * Math.sin(œÜ2));

        return {lat: œÜ2 * deg, lng: Œª2 * deg};
    }

    function initMap() {
        const observer = {lat: latitude, lng: longitude};
        map = new google.maps.Map(document.getElementById("map"), {
            center: observer,
            zoom: 18,
            mapTypeId: "satellite",
            disableDefaultUI: true,
            gestureHandling: "none",     // Disables zooming/panning with mouse/touch
            zoomControl: false,          // Explicitly disables zoom buttons (in case)
            draggable: false,            // Prevents dragging with mouse
            tilt: 0,                      // Enables 45¬∞ tilted imagery where available
            heading: 0                     // Optional: set map rotation
        });

        directionLine = new google.maps.Polyline({
            path: [],
            geodesic: true,
            strokeOpacity: 0, // ‚úÖ prevent base solid line

            strokeColor: "#f6cb3e",

            strokeWeight: 2,
            icons: [{
                icon: {
                    path: 'M 0,-1 0,1',
                    strokeOpacity: 1,
                    scale: 4
                },
                offset: '0',
                repeat: '20px'
            }]
        });

        directionLine.setMap(map);
        console.log("‚úÖ Google Map initialized (satellite view, no UI, dashed line)");
    }


    async function loadCurrentTrackingStatus() {
        try {
            const response = await fetch('/current');
            const data = await response.json();

            const plot = document.getElementById("polarPlot");
            const legend = document.getElementById("polarLegend");

            if (!data.enabled || !data.name) {
                console.log("üì¥ Tracking is disabled.");
                document.getElementById("trackingBanner").textContent = "üì° Currently Tracking: --";
                document.getElementById("stopTrackingWrapper").classList.add("hidden");
                plot.style.display = "none";
                legend.style.display = "none";
            } else {
                console.log("üõ∞Ô∏è Currently tracking:", data.name);
                selectedTarget = data.name;
                document.getElementById("trackingBanner").textContent = `üì° Currently Tracking: ${data.name}`;
                document.getElementById("stopTrackingWrapper").classList.remove("hidden");

                // Ensure the correct radio is selected
                const radioToCheck = document.querySelector(`input[name="trackingTarget"][value="${data.name.toLowerCase()}"]`);
                if (radioToCheck) radioToCheck.checked = true;

                if (data.name.toLowerCase() === "sun" || data.name.toLowerCase() === "moon") {
                    plot.style.display = "none";
                    legend.style.display = "none";
                } else {
                    plot.style.display = "block";
                    legend.style.display = "block";
                    loadAndDrawPolarPlot();
                }
            }
        } catch (error) {
            console.error("‚ùå Failed to load current tracking status:", error);
            document.getElementById("trackingBanner").textContent = "üì° Tracking status unknown";
            document.getElementById("polarPlot").style.display = "none";
            document.getElementById("polarLegend").style.display = "none";
        }
    }


    window.addEventListener('DOMContentLoaded', () => {
        loadCurrentTrackingStatus();
        initGQRX();
    });

    function initGQRX() {
        fetch("/gqrx/init", {method: "POST"})
            .then(res => {
                if (res.ok) {
                    console.log("‚úÖ GQRX settings applied");
                } else {
                    console.log("‚ö†Ô∏è Failed to initialize GQRX");
                }
            })
            .catch(err => {
                console.error("GQRX init error:", err);
                alert("‚ùå Error initializing GQRX");
            });
    }


    window.onload = function () {
        // Initial triggers
        loadSatelliteData()
        buildSunChart();
        loadSunMoonData();

        updateClocks();

        fetch('/observer')
            .then(response => response.json())
            .then(data => {
                latitude = data.latitude;
                longitude = data.longitude;
                const mapsApiKey = data.mapsApiKey;

                console.log("Observer Latitude:", latitude);
                console.log("Observer Longitude:", longitude);
                console.log("Google Maps API Key:", mapsApiKey);

                // Now that you have the key, dynamically load the Google Maps API
                const script = document.createElement('script');
                script.src = `https://maps.googleapis.com/maps/api/js?key=${mapsApiKey}&callback=initMap`;
                script.async = true;
                script.defer = true;
                document.head.appendChild(script);
            })
            .catch(error => console.error('Error fetching observer data:', error));
    };

    setInterval(() => {
        loadSunMoonData();
        loadSatelliteData();
        updateClocks();
    }, 1000);


</script>
        <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
        <script>
    const EARTH_RADIUS_KM = 6371;
    const FOOTPRINT_SEGMENTS = 180;
    const FOOTPRINT_FILL_COLOR = '#ffd502';
    const FOOTPRINT_FILL_OPACITY = 0.3;

    const footprintmap = L.map('footprintmap', {
        zoomControl: false,
        attributionControl: false,
        dragging: false,
        scrollWheelZoom: false,
        doubleClickZoom: false,
        boxZoom: false,
        keyboard: false,
        zoomSnap: 0,          // optional, for smoother lock
        inertia: false,       // disables momentum
        minZoom: 2,
        maxZoom: 2,
        worldCopyJump: false,

    }).setView([0, 0], 2);

    // ‚úÖ Limit map bounds to avoid duplicate wrap-around
    footprintmap.setMaxBounds([
        [-90, -180],
        [90, 180]
    ]);    // Use your original working tile source
    L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/' +
        'World_Imagery/MapServer/tile/{z}/{y}/{x}', {
        attribution: 'Tiles ¬© Esri',
        noWrap: true
    }).addTo(footprintmap);

    function computeFootprintRadiusKm(altitudeKm) {
        const theta = Math.acos(EARTH_RADIUS_KM / (EARTH_RADIUS_KM + altitudeKm));
        return EARTH_RADIUS_KM * theta;
    }

    function generateFootprintCircle(lat, lon, radiusKm, segments) {
        const points = [];
        const rad = Math.PI / 180;
        const deg = 180 / Math.PI;

        for (let i = 0; i < segments; i++) {
            const angle = (360 / segments) * i * rad;

            const lat1 = lat * rad;
            const lon1 = lon * rad;
            const d = radiusKm / EARTH_RADIUS_KM;

            const lat2 = Math.asin(Math.sin(lat1) * Math.cos(d) + Math.cos(lat1) * Math.sin(d) * Math.cos(angle));
            const lon2 = lon1 + Math.atan2(Math.sin(angle) * Math.sin(d) * Math.cos(lat1), Math.cos(d) - Math.sin(lat1) * Math.sin(lat2));

            points.push([lat2 * deg, lon2 * deg]);
        }
        return points;
    }

    const satLayers = {};

    function drawOrUpdateSatellite(sat) {
        const shortNameMatch = sat.name.match(/\(([^)]+)\)/);
        const shortName = shortNameMatch ? shortNameMatch[1] : sat.name;
        const key = sat.name;

        const radiusKm = computeFootprintRadiusKm(sat.altitude);
        const footprintPoints = generateFootprintCircle(sat.sublat, sat.sublon, radiusKm, FOOTPRINT_SEGMENTS);

        const charWidth = 7;
        const padding = 10;
        const iconWidth = shortName.length * charWidth + padding;

        if (satLayers[key]) {
            // Update existing
            satLayers[key].footprint.setLatLngs(footprintPoints);
            satLayers[key].marker.setLatLng([sat.sublat, sat.sublon]);
            satLayers[key].label.setLatLng([sat.sublat, sat.sublon]);
        } else {
            // Create new
            const footprint = L.polygon(footprintPoints, {
                color: FOOTPRINT_FILL_COLOR,
                fillColor: FOOTPRINT_FILL_COLOR,
                fillOpacity: FOOTPRINT_FILL_OPACITY,
                weight: 1
            }).addTo(footprintmap);

            const marker = L.circleMarker([sat.sublat, sat.sublon], {
                radius: 4,
                color: '#ff0202',
                weight: 1,
                fillColor: '#f6cb3e',
                fillOpacity: 1
            }).addTo(footprintmap);

            const label = L.marker([sat.sublat, sat.sublon], {
                icon: L.divIcon({
                    className: 'sat-label',
                    html: shortName,
                    iconSize: [iconWidth, 20],
                    iconAnchor: [iconWidth / 2, 25]
                })
            }).addTo(footprintmap);

            satLayers[key] = {footprint, marker, label};
        }
    }

    function updateSatellitesForFootprintMap() {
        fetch('http://esp32azel.local/satellites')
            .then(response => response.json())
            .then(data => {
                data.forEach(drawOrUpdateSatellite);
            })
            .catch(error => {
                console.error("Failed to fetch satellite data:", error);
            });
    }

    updateSatellitesForFootprintMap(); // Initial call
    setInterval(updateSatellitesForFootprintMap, 5000); // Refresh every 5 seconds
</script>
    </body>
</html>