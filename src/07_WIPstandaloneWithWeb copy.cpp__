// wip.cpp
#include "myconfig.h"
#include <Preferences.h>
#include <WiFi.h>
#include <HTTPClient.h>
#include <time.h>
#include <NTPClient.h>
#include <Sgp4.h>
#include <WebSocketsServer.h>
#include <ESPAsyncWebServer.h>
#include <SPIFFS.h>
#include <ESPmDNS.h>
#include <math.h>
#include <satRotatorFunctions.h>
#include <ArduinoJson.h>

WiFiUDP ntpUDP;
NTPClient timeClient(ntpUDP, "pool.ntp.org", 0, 60000);
Preferences preferences;
Sgp4 sat;
WebSocketsServer webSocket = WebSocketsServer(81);
AsyncWebServer server(80);

unsigned long lastNtpSync = 0;
unsigned long lastTrackTime = 0;
unsigned long lastTLECheck = 0;
unsigned long lastRotorUpdate = 0;
const unsigned long rotorUpdateInterval = 1000; // every 1 second
int tzOffset;
const int numSatellitesToTrack = sizeof(satellitesToTrack) / sizeof(satellitesToTrack[0]);
/**
 * @brief Index of the currently tracked satellite in TrackedSatInfo[]
 * Set to -1 until the user selects a satellite via the Web UI.
 */
int trackedSatIndex = -1;
float previousDist[numSatellitesToTrack] = {0};
unsigned long previousTime[numSatellitesToTrack] = {0};

String currentTrackingTarget = "";
bool trackingEnabled = false;

/**
 * @brief Stores a single point in the satellite's pass path.
 * Each point represents the azimuth and elevation at a given time.
 */
struct PassPoint
{
    float azimuth;   ///< Azimuth in degrees (0‚Äì360)
    float elevation; ///< Elevation in degrees (0‚Äì90)
};


struct SatPassInfo {
    int catnr;
    char satName[32];
    double aosJD;
    double tcaJD;
    double losJD;
    float maxElevation;
    float durationSec;
};
SatPassInfo futurePasses[numSatellitesToTrack][10];  // 10 passes max per satellite
int passCount[numSatellitesToTrack] = {0};  // How many passes are filled per satellite




/**
 * @brief Holds the current satellite pass path sampled every ~15 seconds.
 *
 * - Filled when a satellite is in an active or future pass.
 * - Cleared and refilled at the beginning of each new pass.
 * - Used to render a polar plot of the pass on the web frontend.
 */
#define MAX_PASS_POINTS 100 ///< Max number of points (~25 min at 15s resolution)
PassPoint passPath[MAX_PASS_POINTS];
int numPassPoints = 0; ///< Number of valid points in passPath[]

// ===================================================
// üìå FUNCTION PROTOTYPES
// ===================================================

#pragma region ‚úÖ Core Functions
void setup();
void loop();
#pragma endregion

#pragma region üì° Wi-Fi & Time
void connectToWiFi();
int getTimeZoneOffsetFromAPI();
bool synchronizeTimeWithNTP();
void printUtcAndLocalTime();
#pragma endregion

#pragma region üõ∞Ô∏è TLE Management
void checkAndRefreshTLEsIfNeeded();
void downloadTLEsAndStore();
void loadTLEsIntoRAM();
#pragma endregion

#pragma region üõ∞Ô∏è Satellite Tracking
void loadAndTrackSatelliteByCatalogNumber(int catalogNumber, bool shouldBroadcast);
void generatePassPath(int catalogNumber); // üìà Generates az/el path for polar plot
void trackConfiguredSatellites();
bool predictNextPass(int catalogNumber);
void sendFreqToGQRX(float freqMHz);
#pragma endregion

#pragma region ‚òÄÔ∏èüåô Sun & Moon Calculations
double getJulianDate();
double julianFromYMD(int year, int month, int day);
void getSunAzElAndRiseSet(double &azimuth, double &elevation, double &sunriseUTC, double &sunsetUTC);
void getMoonAzElAndRiseSet(double &azimuth, double &elevation, double &moonriseUTC, double &moonsetUTC);
String getSunMoonJson();
#pragma endregion

#pragma region üßÆ Math & Formatting Helpers
double fixAngle(double deg);
double jdToHour(double jd);
String formatTimeUTC(double hourUTC);
String formatTimeLocal(double hourUTC);
String formatDurationMMSS(double seconds);
String formatDurationHHMM(double seconds);
String formatTimeStamp(int d, int m, int y, int h, int min);
String StringFormat(const char *fmt, ...);
#pragma endregion

// make nice
void controlSteppers(float azi, float ele);

float AzimuthForRotator = 0;
float ElevationForRotator = 0;

/**
 * @brief Lists the files stored in SPIFFS and prints the usage percentage of the flash memory.
 *
 * This function mounts the SPIFFS filesystem, lists the files stored in the filesystem,
 * and prints the percentage of flash memory used. It also displays the number of files
 * stored and their names, and the flash memory stats in a user-friendly format with
 * emojis for easy reading.
 *
 * üìÇ Displays files in SPIFFS
 * üíæ Prints memory usage in percentage
 * ‚úÖ Provides useful diagnostics in case of errors
 */
void listFilesAndPrintUsage()
{
    // Mount SPIFFS
    if (!SPIFFS.begin(true))
    {
        Serial.println("‚ùå SPIFFS Mount Failed");
        return;
    }

    // Open the root directory
    File root = SPIFFS.open("/");
    if (!root)
    {
        Serial.println("‚ùå Failed to open directory");
        return;
    }

    Serial.println("üìÇ Files stored in SPIFFS:");
    File file = root.openNextFile();
    int fileCount = 0;

    // List all files in the directory
    while (file)
    {
        Serial.print("  üìÑ File: ");
        Serial.println(file.name());
        file = root.openNextFile();
        fileCount++;
    }

    if (fileCount == 0)
    {
        Serial.println("üö´ No files found.");
    }

    // Close the root directory
    root.close();

    // Print SPIFFS memory usage
    uint32_t total = SPIFFS.totalBytes();
    uint32_t used = SPIFFS.usedBytes();
    float percentUsed = (float)used / (float)total * 100.0;

    Serial.println();
    Serial.print("üíæ Total SPIFFS space: ");
    Serial.print(total);
    Serial.print(" bytes, Used: ");
    Serial.print(used);
    Serial.print(" bytes, ");
    Serial.print(percentUsed);
    Serial.println("% used");
    Serial.println("üìù Done listing files and showing memory usage.");
}

// ===============================================
// üõ∞Ô∏è TLE RAM Cache
// This avoids reading TLEs from Preferences every second.
// It's filled once at boot using loadTLEsIntoRAM().
// ===============================================
struct TLEData
{
    String name;
    String tle1;
    String tle2;
};

TLEData TLECache[numSatellitesToTrack];

/**
 * üóÇÔ∏è loadTLEsIntoRAM()
 *
 * Loads TLE data for all configured satellites from Preferences into RAM.
 * - Fills the TLECache[] array based on `satellitesToTrack[]`.
 * - Ensures that all data is ready for runtime use.
 * - Should be called once at boot after TLEs are downloaded.
 */
void loadTLEsIntoRAM()
{
    Serial.println("üß† Loading TLEs into RAM cache...");
    preferences.begin("tle-storage", true);

    for (int i = 0; i < numSatellitesToTrack; ++i)
    {
        int catnr = satellitesToTrack[i];
        String base = String(catnr);

        TLECache[i].name = preferences.getString((base + "_name").c_str(), "");
        TLECache[i].tle1 = preferences.getString((base + "_tle1").c_str(), "");
        TLECache[i].tle2 = preferences.getString((base + "_tle2").c_str(), "");

        Serial.printf("üõ∞Ô∏è  Cached %s (CATNR %d)", TLECache[i].name.c_str(), catnr);
        Serial.println("");
    }

    preferences.end();
}

// üåûüåï Sun and Moon Tracking Data
// This struct holds all computed data for the Sun and Moon,
// including azimuth, elevation, and rise/set times in UTC.
// It's updated every second in the loop() and can be accessed
// by the web server or WebSocket handler to provide live data.
// =======================================================
// Global struct and instance
struct SunMoonStruct
{
    double sunAzimuth, sunElevation, sunRiseUTC, sunSetUTC;
    double moonAzimuth, moonElevation, moonRiseUTC, moonSetUTC;
};
SunMoonStruct SunMoonInfo;

struct SatelliteInfo
{
    char name[32];
    float azimuth, elevation, distance;
    float frequencyMHz;
    float correctedFreqMHz;
    float dopplerHz;
    double aosUTC, tcaUTC, losUTC;
    float maxElevation;
    float azAtAOS;       // üì° Azimuth when satellite appears (AOS)
    float azAtLOS;       // üì° Azimuth when satellite disappears (LOS)
    String passDuration; // ‚è±Ô∏è Duration in MM:SS
    String timeToEvent;  // ‚è≥ Time until AOS or LOS in HH:MM
    char nextEventType[4]; // "AOS" or "LOS"

};

SatelliteInfo TrackedSatInfo[numSatellitesToTrack]; // Updated every second

int findSatelliteIndexByName(const String &name)
{
    for (int i = 0; i < numSatellitesToTrack; i++)
    {
        if (String(TrackedSatInfo[i].name) == name)
        {
            return i;
        }
    }
    return -1;
}

String StringFormat(const char *fmt, ...)
{
    char buf[128];
    va_list args;
    va_start(args, fmt);
    vsnprintf(buf, sizeof(buf), fmt, args);
    va_end(args);
    return String(buf);
}

String formatTimeStampFromJD(double jd, int tzHoursOffset = 0)
{
    int y, m, d, h, min;
    double sec;
    invjday(jd, tzHoursOffset, false, y, m, d, h, min, sec);
    return formatTimeStamp(d, m, y, h, min);
}

double jdToHour(double jd)
{
    double dayFraction = jd - (int)jd;
    return dayFraction * 24.0;
}

// FOR SUN AND MOON

double getJulianDate();

const double DEG2RAD = PI / 180.0;
const double RAD2DEG = 180.0 / PI;

double fixAngle(double deg)
{
    return fmod(fmod(deg, 360.0) + 360.0, 360.0);
}

double getJulianDate()
{
    time_t now = time(nullptr);
    struct tm *utc = gmtime(&now);

    int year = utc->tm_year + 1900;
    int month = utc->tm_mon + 1;
    int day = utc->tm_mday;
    int hour = utc->tm_hour;
    int minute = utc->tm_min;
    int second = utc->tm_sec;

    if (month <= 2)
    {
        year -= 1;
        month += 12;
    }

    int A = year / 100;
    int B = 2 - A + A / 4;

    double JD = int(365.25 * (year + 4716)) +
                int(30.6001 * (month + 1)) +
                day + B - 1524.5 +
                (hour + minute / 60.0 + second / 3600.0) / 24.0;
    return JD;
}

String formatTimeUTC(double hourUTC)
{
    if (hourUTC < 0 || hourUTC >= 24)
        return "--:--";
    int h = int(hourUTC);
    int m = int((hourUTC - h) * 60);
    char buffer[6];
    snprintf(buffer, sizeof(buffer), "%02d:%02d", h, m);
    return String(buffer);
}

String formatTimeLocal(double hourUTC)
{
    if (hourUTC < 0 || hourUTC >= 24)
        return "--:--";

    double offsetHours = tzOffset / 3600.0;
    hourUTC += offsetHours;
    if (hourUTC >= 24)
        hourUTC -= 24;
    if (hourUTC < 0)
        hourUTC += 24;

    int h = int(hourUTC);
    int m = int((hourUTC - h) * 60);
    char buffer[6];
    snprintf(buffer, sizeof(buffer), "%02d:%02d", h, m);
    return String(buffer);
}

/**
 * üåû getSunAzElAndRiseSet()
 *
 * Computes and prints:
 * - The Sun's **azimuth** and **elevation**
 * - **Sunrise** and **sunset times** in UTC (fractional hours)
 * - **Transit time** (solar noon) and **day duration**
 * - Formatted local/UTC time strings for debugging/logging
 *
 * Parameters:
 *   azimuth     ‚Üí (output) sun azimuth in degrees
 *   elevation   ‚Üí (output) sun elevation in degrees
 *   sunriseUTC  ‚Üí (output) sunrise time in fractional UTC hours
 *   sunsetUTC   ‚Üí (output) sunset time in fractional UTC hours
 */
void getSunAzElAndRiseSet(double &azimuth, double &elevation, double &sunriseUTC, double &sunsetUTC)
{
    double JD = getJulianDate();
    double d = JD - 2451545.0;

    // --- Solar position calculations ---

    double g = radians(fmod(357.529 + 0.98560028 * d, 360));
    double q = fmod(280.459 + 0.98564736 * d, 360);
    double L = fmod(q + 1.915 * sin(g) + 0.020 * sin(2 * g), 360);
    double e = radians(23.439 - 0.00000036 * d);
    double L_rad = radians(L);

    double RA = atan2(cos(e) * sin(L_rad), cos(L_rad));
    double dec = asin(sin(e) * sin(L_rad));

    double GMST = fmod(280.16 + 360.9856235 * d, 360);
    double LST = radians(fmod(GMST + OBSERVER_LONGITUDE, 360));
    double HA = LST - RA;

    double latRad = radians(OBSERVER_LATITUDE);
    elevation = asin(sin(dec) * sin(latRad) + cos(dec) * cos(latRad) * cos(HA));
    azimuth = atan2(-sin(HA), tan(dec) * cos(latRad) - sin(latRad) * cos(HA));
    azimuth = fmod(degrees(azimuth) + 360, 360);
    elevation = degrees(elevation);

    // --- Sunrise/Sunset calculation ---

    double cosH = (cos(radians(90.833)) - sin(latRad) * sin(dec)) / (cos(latRad) * cos(dec));

    if (cosH < -1)
    {
        sunriseUTC = 0;
        sunsetUTC = 24;
    }
    else if (cosH > 1)
    {
        sunriseUTC = -1;
        sunsetUTC = -1;
    }
    else
    {
        double H = degrees(acos(cosH)) / 15.0;
        double transitUTC = fmod((720 - 4 * OBSERVER_LONGITUDE) / 60.0, 24);

        sunriseUTC = transitUTC - H;
        sunsetUTC = transitUTC + H;

        double dayDuration = sunsetUTC - sunriseUTC;
        Serial.printf("üåû Day duration: %.2f hours\n", dayDuration);
        Serial.printf("üïõ Solar noon (transit): %.2f UTC\n", transitUTC);
    }

    // --- Print current sun position and formatted times ---
    Serial.printf("‚òÄÔ∏è  Sun Azimuth: %.2f¬∞, Elevation: %.2f¬∞\n", azimuth, elevation);
    Serial.printf("üåÖ Sunrise: %s local / %s UTC\n",
                  formatTimeLocal(sunriseUTC).c_str(),
                  formatTimeUTC(sunriseUTC).c_str());
    Serial.printf("üåá Sunset : %s local / %s UTC\n",
                  formatTimeLocal(sunsetUTC).c_str(),
                  formatTimeUTC(sunsetUTC).c_str());
}

double julianFromYMD(int year, int month, int day)
{
    if (month <= 2)
    {
        year--;
        month += 12;
    }
    int A = year / 100;
    int B = 2 - A + A / 4;
    return floor(365.25 * (year + 4716)) +
           floor(30.6001 * (month + 1)) +
           day + B - 1524.5;
}

/**
 * üåï getMoonAzElAndRiseSet()
 *
 * Computes Moon's current azimuth and elevation, along with rise and set times.
 * - Uses simplified orbital elements and trigonometry.
 * - Computes moonrise and moonset by hourly elevation sweep.
 * - Times are returned in UTC fractional hours.
 * - Also prints results in local and UTC format.
 */
void getMoonAzElAndRiseSet(double &azimuth, double &elevation, double &moonriseUTC, double &moonsetUTC)
{
    double JD = getJulianDate();
    double D = JD - 2451545.0;

    // --- Position calculation ---
    double L = fixAngle(218.316 + 13.176396 * D);     // Mean longitude
    double M = fixAngle(134.963 + 13.064993 * D);     // Mean anomaly
    double F = fixAngle(93.272 + 13.229350 * D);      // Argument of latitude
    double D_sun = fixAngle(297.850 + 12.190749 * D); // Elongation
    double N = fixAngle(125.044 - 0.0529538 * D);     // Ascending node

    // Convert to radians
    L *= DEG2RAD;
    M *= DEG2RAD;
    F *= DEG2RAD;
    D_sun *= DEG2RAD;
    N *= DEG2RAD;

    // Ecliptic longitude and latitude
    double lon = L + DEG2RAD * (6.289 * sin(M) +
                                1.274 * sin(2 * D_sun - M) +
                                0.658 * sin(2 * D_sun) +
                                0.214 * sin(2 * M) +
                                0.11 * sin(D_sun));
    double lat = DEG2RAD * (5.128 * sin(F) +
                            0.280 * sin(M + F) +
                            0.277 * sin(M - F) +
                            0.173 * sin(2 * D_sun - F));

    double e = DEG2RAD * (23.439 - 0.00000036 * D);

    double x = cos(lat) * cos(lon);
    double y = cos(lat) * sin(lon) * cos(e) - sin(lat) * sin(e);
    double z = cos(lat) * sin(lon) * sin(e) + sin(lat) * cos(e);

    double RA = atan2(y, x);
    double dec = asin(z);

    double T = D / 36525.0;
    double GMST = fixAngle(280.46061837 + 360.98564736629 * D +
                           T * T * (0.000387933 - T / 38710000.0));
    double LST = DEG2RAD * fixAngle(GMST + OBSERVER_LONGITUDE);

    double HA = LST - RA;

    double latRad = DEG2RAD * OBSERVER_LATITUDE;
    elevation = asin(sin(dec) * sin(latRad) + cos(dec) * cos(latRad) * cos(HA));
    azimuth = atan2(-sin(HA),
                    tan(dec) * cos(latRad) - sin(latRad) * cos(HA));
    azimuth = fixAngle(RAD2DEG * azimuth);
    elevation = RAD2DEG * elevation;

    // --- Moonrise and Moonset (hourly sweep) ---
    time_t now = time(nullptr);
    struct tm *utc = gmtime(&now);
    int year = utc->tm_year + 1900;
    int month = utc->tm_mon + 1;
    int day = utc->tm_mday;

    double jdMidnight = julianFromYMD(year, month, day);

    double prevEl = 0, currEl = 0;
    bool foundRise = false, foundSet = false;
    moonriseUTC = -1;
    moonsetUTC = -1;

    for (int h = 0; h <= 24; ++h)
    {
        double testJD = jdMidnight + h / 24.0;
        double dtest = testJD - 2451545.0;

        double Lm = fixAngle(218.316 + 13.176396 * dtest);
        double Mm = fixAngle(134.963 + 13.064993 * dtest);
        double Fm = fixAngle(93.272 + 13.229350 * dtest);
        double Dm = fixAngle(297.850 + 12.190749 * dtest);

        Lm *= DEG2RAD;
        Mm *= DEG2RAD;
        Fm *= DEG2RAD;
        Dm *= DEG2RAD;

        double lonm = Lm + DEG2RAD * (6.289 * sin(Mm) +
                                      1.274 * sin(2 * Dm - Mm) +
                                      0.658 * sin(2 * Dm) +
                                      0.214 * sin(2 * Mm) +
                                      0.11 * sin(Dm));
        double latm = DEG2RAD * (5.128 * sin(Fm));

        double em = DEG2RAD * (23.439 - 0.00000036 * dtest);
        double xm = cos(latm) * cos(lonm);
        double ym = cos(latm) * sin(lonm) * cos(em) - sin(latm) * sin(em);
        double zm = cos(latm) * sin(lonm) * sin(em) + sin(latm) * cos(em);

        double RAm = atan2(ym, xm);
        double decm = asin(zm);

        double GMSTm = fixAngle(280.46061837 + 360.98564736629 * dtest);
        double LSTm = DEG2RAD * fixAngle(GMSTm + OBSERVER_LONGITUDE);
        double HAm = LSTm - RAm;

        double elm = asin(sin(decm) * sin(latRad) + cos(decm) * cos(latRad) * cos(HAm));
        elm = RAD2DEG * elm;

        currEl = elm;

        if (h > 0)
        {
            if (!foundRise && prevEl < 0 && currEl >= 0)
            {
                double t = h - 1 + (-prevEl / (currEl - prevEl));
                moonriseUTC = t;
                foundRise = true;
            }
            if (!foundSet && prevEl >= 0 && currEl < 0)
            {
                double t = h - 1 + (prevEl / (prevEl - currEl));
                moonsetUTC = t;
                foundSet = true;
            }
        }

        prevEl = currEl;
    }

    // üåï Print to Serial
    Serial.printf("üåï Moon Azimuth: %.2f¬∞, Elevation: %.2f¬∞\n", azimuth, elevation);
    Serial.printf("üåô Moonrise: %s local / %s UTC\n",
                  formatTimeLocal(moonriseUTC).c_str(),
                  formatTimeUTC(moonriseUTC).c_str());
    Serial.printf("üåô Moonset : %s local / %s UTC\n",
                  formatTimeLocal(moonsetUTC).c_str(),
                  formatTimeUTC(moonsetUTC).c_str());
}

// Returns the current Sun and Moon information in JSON format
// This is useful for AJAX requests from a web interface
String getSunMoonJson()
{
    String json = "{";
    json += "\"sunAzimuth\":" + String(SunMoonInfo.sunAzimuth, 2) + ",";
    json += "\"sunElevation\":" + String(SunMoonInfo.sunElevation, 2) + ",";
    json += "\"sunRiseUTC\":\"" + formatTimeUTC(SunMoonInfo.sunRiseUTC) + "\",";
    json += "\"sunSetUTC\":\"" + formatTimeUTC(SunMoonInfo.sunSetUTC) + "\",";
    json += "\"moonAzimuth\":" + String(SunMoonInfo.moonAzimuth, 2) + ",";
    json += "\"moonElevation\":" + String(SunMoonInfo.moonElevation, 2) + ",";
    json += "\"moonRiseUTC\":\"" + formatTimeUTC(SunMoonInfo.moonRiseUTC) + "\",";
    json += "\"moonSetUTC\":\"" + formatTimeUTC(SunMoonInfo.moonSetUTC) + "\"";
    json += "}";
    return json;
}

/**
 * üì∂ connectToWiFi()
 *
 * Connects to Wi-Fi using primary or fallback credentials.
 * - Sets a custom hostname for both DHCP (`.fritz.box`) and mDNS (`.local`) resolution.
 * - Starts mDNS responder if possible.
 * - Shows all connection info via Serial.
 */
void connectToWiFi()
{
    WiFi.setHostname(DEVICE_HOSTNAME);
    int attempt = 0;
    const int maxAttempts = 5;

    Serial.println("üîå Starting Wi-Fi connection...");
    Serial.printf("üè∑Ô∏è  Setting hostname: %s\n", DEVICE_HOSTNAME);

    while (WiFi.status() != WL_CONNECTED)
    {
        const bool usePrimary = (attempt < maxAttempts);
        const char *ssid = usePrimary ? WIFI_SSID : WIFI_SSID_ALT;
        const char *password = usePrimary ? WIFI_PASSWORD : WIFI_PASSWORD_ALT;

        Serial.printf("üì° Attempt %d (%s)...\n", attempt + 1, usePrimary ? "Primary SSID" : "Fallback SSID");
        Serial.printf("‚Üí Connecting to SSID: %s\n", ssid);

        WiFi.disconnect(true);
        WiFi.begin(ssid, password);

        for (int i = 0; i < 10; ++i)
        {
            if (WiFi.status() == WL_CONNECTED)
            {
                Serial.println("‚úÖ Connected to Wi-Fi!");
                Serial.printf("üì∂ SSID    : %s\n", ssid);
                Serial.printf("üì° RSSI    : %ld dBm\n", WiFi.RSSI());
                Serial.printf("üåê IP Addr : %s\n", WiFi.localIP().toString().c_str());
                Serial.printf("üè∑Ô∏è  Hostname: %s\n", DEVICE_HOSTNAME);

                // üåê Start mDNS so device is accessible via hostname.local
                if (MDNS.begin(DEVICE_HOSTNAME))
                {
                    Serial.printf("üü¢ mDNS started! Access via http://%s.local\n", DEVICE_HOSTNAME);
                }
                else
                {
                    Serial.println("‚ùå Failed to start mDNS responder.");
                }

                return;
            }
            delay(500);
        }

        Serial.printf("‚ö†Ô∏è  Connection to %s failed.\n", ssid);

        attempt++;
        if (attempt == maxAttempts * 2)
        {
            Serial.println("üîÅ Retrying Wi-Fi connections from scratch...");
            attempt = 0;
        }
    }
}

/**
 * üïì getTimeZoneOffsetFromAPI()
 *
 * Retrieves the current timezone offset (in seconds) from the TimeZoneDB API
 * using the device's geographic position (hardcoded for now).
 *
 * - Parses the JSON response to extract the "gmtOffset" field.
 * - Returns the offset in seconds (e.g., 7200 for UTC+2).
 * - If the API request fails or parsing fails, falls back to UTC+2.
 */
int getTimeZoneOffsetFromAPI()
{
    String url = "http://api.timezonedb.com/v2.1/get-time-zone?key=" +
                 String(TIMEZONE_API_KEY) +
                 "&format=json&by=position&lat=46.2044&lng=6.1432";

    Serial.println("üåç Requesting timezone offset from TimeZoneDB...");
    Serial.println("üåê URL: " + url);

    HTTPClient http;
    http.begin(url);
    int httpCode = http.GET();

    if (httpCode == 200)
    {
        String payload = http.getString();
        int idx = payload.indexOf("\"gmtOffset\":");

        if (idx >= 0)
        {
            int end = payload.indexOf(",", idx);
            String offsetStr = payload.substring(idx + 12, end);
            int offset = offsetStr.toInt();

            Serial.printf("‚úÖ Timezone offset received: %d seconds (%+.1f hours)\n",
                          offset, offset / 3600.0);
            http.end();
            return offset;
        }
        else
        {
            Serial.println("‚ö†Ô∏è  Could not find \"gmtOffset\" in response.");
        }
    }
    else
    {
        Serial.printf("‚ùå HTTP request failed. Code: %d\n", httpCode);
    }

    http.end();

    // Fallback to UTC+2
    Serial.println("‚è±Ô∏è  Using fallback offset: DEFAULT_TZ_OFFSET seconds");
    return DEFAULT_TZ_OFFSET;
}

/**
 * üïí synchronizeTimeWithNTP()
 *
 * Attempts to synchronize system time using a list of NTP servers.
 * - Tries up to 3 times per server until time is successfully set.
 * - Updates the system clock using `settimeofday`.
 * - Logs each server attempt, success, or failure to Serial.
 *
 * Returns:
 *   true if synchronization succeeded, false otherwise.
 */
bool synchronizeTimeWithNTP()
{
    const char *ntpServers[] = {
        "time.google.com",
        "time.nist.gov",
        "time.cloudflare.com",
        "pool.ntp.org",
        "europe.pool.ntp.org"};
    const int maxRetries = 3;

    Serial.println("üïí Starting NTP time synchronization...");

    for (auto server : ntpServers)
    {
        timeClient.end();
        timeClient.setPoolServerName(server);
        timeClient.begin();

        Serial.printf("üåê Trying NTP server: %s\n", server);

        for (int attempt = 1; attempt <= maxRetries; ++attempt)
        {
            Serial.printf("  üîÅ Attempt %d/%d...\n", attempt, maxRetries);
            if (timeClient.update() && timeClient.getEpochTime() > 1000000000)
            {
                time_t currentTime = timeClient.getEpochTime();
                struct timeval nowTime;
                nowTime.tv_sec = currentTime;
                nowTime.tv_usec = 0;
                settimeofday(&nowTime, nullptr);

                struct tm *tm_utc = gmtime(&currentTime);
                Serial.printf("‚úÖ Time synced successfully from %s\n", server);
                Serial.printf("üïí UTC Time: %04d-%02d-%02d %02d:%02d:%02d\n",
                              tm_utc->tm_year + 1900, tm_utc->tm_mon + 1, tm_utc->tm_mday,
                              tm_utc->tm_hour, tm_utc->tm_min, tm_utc->tm_sec);

                return true;
            }
            delay(2000);
        }

        Serial.printf("‚ö†Ô∏è  Failed to sync with %s\n", server);
    }

    Serial.println("‚ùå All NTP servers failed. Time not synced.");
    return false;
}

/**
 * üïí printUtcAndLocalTime()
 *
 * Displays both the current UTC time and the local time using the manually applied
 * timezone offset (tzOffset, in seconds). This method avoids relying on system timezone
 * settings (`setenv`, `tzset`, `localtime`) to maintain cross-platform consistency.
 *
 * - Uses `gmtime()` to extract the broken-down UTC time.
 * - Calculates the local hour manually by applying `tzOffset / 3600.0`.
 * - Handles day wraparound when local time goes over 24 or below 0.
 *
 * Example Output:
 * üìÖ UTC Time   : 22/04/2025 12:45
 * üìÖ Local Time : 22/04/2025 14:45
 */
void printUtcAndLocalTime()
{
    time_t now = time(nullptr);
    struct tm *utc = gmtime(&now);

    double h = utc->tm_hour + utc->tm_min / 60.0;
    double localH = h + tzOffset / 3600.0;

    if (localH >= 24)
        localH -= 24;
    if (localH < 0)
        localH += 24;

    Serial.printf("üìÖ UTC Time   : %02d/%02d/%04d %02d:%02d\n",
                  utc->tm_mday, utc->tm_mon + 1, utc->tm_year + 1900,
                  utc->tm_hour, utc->tm_min);

    Serial.printf("üìÖ Local Time : %02d/%02d/%04d %02d:%02d\n",
                  utc->tm_mday, utc->tm_mon + 1, utc->tm_year + 1900,
                  int(localH), int((localH - int(localH)) * 60));
}

/**
 * üîÑ checkAndRefreshTLEsIfNeeded()
 *
 * This function checks whether TLE data needs to be refreshed.
 *
 * Logic:
 * - Retrieves the timestamp of the last TLE update from Preferences.
 * - If the update has never been performed (`last_update == 0`), it triggers a full download.
 * - If any configured satellite is missing TLE data in Preferences, it also forces a download.
 * - If the existing TLEs are older than the threshold (`TLE_UPDATE_INTERVAL_HOURS`), it refreshes.
 * - Otherwise, it logs that no update is needed.
 *
 * This ensures that:
 * - Newly added satellites get their TLEs immediately after first boot.
 * - Users don't have to wait several hours for new entries to populate.
 */
void checkAndRefreshTLEsIfNeeded()
{
    preferences.begin("tle-storage", true);
    unsigned long lastUpdate = preferences.getULong("last_update", 0);

    // üîç Check for missing TLEs
    bool anyMissingTLE = false;
    for (int i = 0; i < numSatellitesToTrack; ++i)
    {
        String base = String(satellitesToTrack[i]);
        String tle1 = preferences.getString((base + "_tle1").c_str(), "");
        String tle2 = preferences.getString((base + "_tle2").c_str(), "");

        if (tle1 == "" || tle2 == "")
        {
            Serial.printf("‚ùì Missing TLEs for CATNR %s\n", base.c_str());
            anyMissingTLE = true;
            break;
        }
    }
    preferences.end();

    if (lastUpdate == 0)
    {
        Serial.println("üÜï TLEs have never been updated. Starting initial download...");
        downloadTLEsAndStore();
        return;
    }

    if (anyMissingTLE)
    {
        Serial.println("üì• One or more TLEs missing. Forcing immediate TLE download...");
        downloadTLEsAndStore();
        return;
    }

    // ‚è≥ Check age-based refresh
    unsigned long now = time(nullptr);
    unsigned long interval = TLE_UPDATE_INTERVAL_HOURS * 3600;
    unsigned long age = now - lastUpdate;
    float ageHours = age / 3600.0;

    Serial.printf("‚è±Ô∏è  TLE age: %.2f hours (threshold: %d hours)\n", ageHours, TLE_UPDATE_INTERVAL_HOURS);

    if (age > interval)
    {
        Serial.println("üîÑ TLE update required. Downloading new TLEs...");
        downloadTLEsAndStore();
    }
    else
    {
        Serial.println("‚úÖ No TLE update needed. Using current data.");
    }
}

/**
 * üì• downloadTLEsAndStore()
 *
 * Downloads TLE data for all configured satellites and stores it in Preferences.
 * - Fetches TLE from Celestrak using each satellite's catalog number.
 * - Stores name, line1, and line2 in Preferences under keys like "25544_name".
 * - Also stores the timestamp of the last successful update.
 *
 * Notes:
 * - TLEs are saved under namespace `"tle-storage"`.
 * - A small delay is added between downloads to avoid flooding.
 */
void downloadTLEsAndStore()
{
    Serial.println("üåê Starting TLE download and storage...");

    preferences.begin("tle-storage", false);

    for (const auto &sat : satellites)
    {
        int catnr = sat.catalogNumber;

        // üåç Build Celestrak URL
        String url = "http://www.celestrak.org/NORAD/elements/gp.php?CATNR=" + String(catnr) + "&FORMAT=TLE";
        Serial.println("üîó Fetching: " + url);

        HTTPClient http;
        http.begin(url);
        int code = http.GET();

        if (code == 200)
        {
            // üõ∞Ô∏è Parse TLE lines
            String payload = http.getString();
            int n1 = payload.indexOf('\n');
            int n2 = payload.indexOf('\n', n1 + 1);

            String name = payload.substring(0, n1);
            name.trim();
            String l1 = payload.substring(n1 + 1, n2);
            l1.trim();
            String l2 = payload.substring(n2 + 1);
            l2.trim();

            // üß† Store into Preferences
            String base = String(catnr);
            preferences.putString((base + "_name").c_str(), name);
            preferences.putString((base + "_tle1").c_str(), l1);
            preferences.putString((base + "_tle2").c_str(), l2);

            Serial.printf("‚úÖ Stored: %s (CATNR %d)\n", name.c_str(), catnr);
        }
        else
        {
            Serial.printf("‚ùå HTTP error %d for CATNR %d\n", code, catnr);
        }

        http.end();
        delay(500); // ‚è≥ Delay to avoid hitting rate limits
    }

    // üïì Store last update time
    preferences.putULong("last_update", time(nullptr));
    preferences.end();

    Serial.println("üì¶ TLE download and storage complete.");
}

/**
 * üïí formatDurationMMSS
 *
 * Converts a duration in seconds to a MM:SS format.
 * Suitable for short durations like satellite pass time.
 */
String formatDurationMMSS(double seconds)
{
    int total = (int)(seconds + 0.5); // round
    int mm = total / 60;
    int ss = total % 60;
    char buf[6];
    snprintf(buf, sizeof(buf), "%02d:%02d", mm, ss);
    return String(buf);
}

/**
 * ‚è≥ formatDurationHHMM
 *
 * Converts a duration in seconds to a HH:MM format.
 * Suitable for displaying "time until next pass".
 */
String formatDurationHHMM(double seconds)
{
    int total = (int)(seconds + 30); // round to nearest minute
    int hh = total / 3600;
    int mm = (total % 3600) / 60;
    char buf[6];
    snprintf(buf, sizeof(buf), "%02d:%02d", hh, mm);
    return String(buf);
}

/**
 * üïí formatTimeStamp()
 *
 * Formats a full date + time (from int values) into "DD/MM/YYYY HH:MM".
 * Useful for nicely aligned logging of UTC/local AOS/TCA/LOS times.
 */
String formatTimeStamp(int d, int m, int y, int h, int min)
{
    char buffer[20];
    // snprintf(buffer, sizeof(buffer), "%02d/%02d/%04d %02d:%02d", d, m, y, h, min);
    snprintf(buffer, sizeof(buffer), "%02d.%02d %02d:%02d", d, m, h, min);

    return String(buffer);
}

/**
 * üì• parseJsonBody()
 *
 * Parses a JSON body from an HTTP POST request and populates a DynamicJsonDocument.
 *
 * - Validates that the request has a "body" parameter (common with AsyncWebServer POSTs).
 * - Deserializes the body into the provided `doc` reference.
 * - Returns `true` if parsing was successful, `false` otherwise.
 * - Automatically sends an appropriate HTTP error response if parsing fails.
 *
 * Parameters:
 *   request   - the incoming AsyncWebServerRequest object
 *   doc       - a reference to a DynamicJsonDocument that will be filled
 *   capacity  - (optional) memory size for the document, default is 512 bytes
 *
 * Returns:
 *   true  ‚Üí parsing succeeded, doc is valid
 *   false ‚Üí parsing failed or missing body, error response already sent
 */
bool parseJsonBody(AsyncWebServerRequest *request, DynamicJsonDocument &doc, size_t capacity = 512)
{
    String body;
    if (request->hasArg("plain"))
    {
        body = request->arg("plain");
    }
    else
    {
        request->send(400, "application/json", "{\"error\":\"Missing JSON body\"}");
        return false;
    }

    DeserializationError error = deserializeJson(doc, body);
    if (error)
    {
        request->send(400, "application/json", "{\"error\":\"Invalid JSON\"}");
        return false;
    }

    return true;
}

/**
 * üì° predictNextPass()
 *
 * Computes and prints the next or current satellite pass for the given catalog number.
 * - Checks if satellite is already visible and adjusts prediction start time accordingly.
 * - Uses TLE data from the RAM cache (TLECache[]).
 * - Calculates AOS, TCA, LOS in both UTC and local time using the global `tzOffset`.
 * - Computes pass duration (MM:SS) and time until AOS (or LOS if visible).
 *
 * Returns:
 *   true if a pass is found and printed, false otherwise.
 */
bool predictNextPass(int catalogNumber)
{
    // Step 1: Find satellite index in RAM cache
    int satIndex = -1;
    for (int i = 0; i < numSatellitesToTrack; ++i)
    {
        if (satellitesToTrack[i] == catalogNumber)
        {
            satIndex = i;
            break;
        }
    }

    if (satIndex == -1)
    {
        Serial.printf("‚ùå Satellite with catalog number %d not found in TLECache.\n", catalogNumber);
        return false;
    }

    String name = TLECache[satIndex].name;
    String l1 = TLECache[satIndex].tle1;
    String l2 = TLECache[satIndex].tle2;

    if (name == "" || l1 == "" || l2 == "")
    {
        Serial.printf("‚ùå Missing TLE data for CATNR %d\n", catalogNumber);
        return false;
    }

    // Step 2: Prepare Sgp4 predictor
    char nameBuf[64], l1Buf[130], l2Buf[130];
    strncpy(nameBuf, name.c_str(), sizeof(nameBuf));
    strncpy(l1Buf, l1.c_str(), sizeof(l1Buf));
    strncpy(l2Buf, l2.c_str(), sizeof(l2Buf));

    Sgp4 predictor;
    predictor.site(OBSERVER_LATITUDE, OBSERVER_LONGITUDE, OBSERVER_ALTITUDE);
    predictor.init(nameBuf, l1Buf, l2Buf);

    // Step 3: Determine start time for prediction
    time_t now = time(nullptr);
    time_t lookbackStart = now;
    bool satCurrentlyVisible = false;

    const int maxLookbackMinutes = 20;
    for (int i = maxLookbackMinutes; i >= 0; --i)
    {
        time_t t = now - i * 60;
        predictor.findsat(static_cast<unsigned long>(t));
        if (predictor.satEl > 0)
        {
            satCurrentlyVisible = true;
            lookbackStart = t;
            break;
        }
    }

    predictor.initpredpoint(static_cast<unsigned long>(lookbackStart), 0.0);

    // Step 4: Compute next pass (could include current if visible)
    passinfo pass;
    if (!predictor.nextpass(&pass, 20))
    {
        Serial.printf("‚ùå Prediction failed for %s (CATNR %d)\n", nameBuf, catalogNumber);
        return false;
    }

    // Step 5: Convert AOS, TCA, LOS to human-readable times
    int y, m, d, h, min;
    double sec;
    int tz = tzOffset / 3600;

    invjday(pass.jdstart, 0, false, y, m, d, h, min, sec);
    String aosUTC = formatTimeStamp(d, m, y, h, min);
    invjday(pass.jdstart, tz, false, y, m, d, h, min, sec);
    String aosLocal = formatTimeStamp(d, m, y, h, min);

    invjday(pass.jdmax, 0, false, y, m, d, h, min, sec);
    String tcaUTC = formatTimeStamp(d, m, y, h, min);
    invjday(pass.jdmax, tz, false, y, m, d, h, min, sec);
    String tcaLocal = formatTimeStamp(d, m, y, h, min);

    invjday(pass.jdstop, 0, false, y, m, d, h, min, sec);
    String losUTC = formatTimeStamp(d, m, y, h, min);
    invjday(pass.jdstop, tz, false, y, m, d, h, min, sec);
    String losLocal = formatTimeStamp(d, m, y, h, min);

    // Step 6: Compute durations
    double durationSec = (pass.jdstop - pass.jdstart) * 86400.0;
    double secondsUntilEvent = satCurrentlyVisible
                                   ? (pass.jdstop - (now / 86400.0 + 2440587.5)) * 86400.0   // Until LOS
                                   : (pass.jdstart - (now / 86400.0 + 2440587.5)) * 86400.0; // Until AOS

    // Prevent negative duration formatting
    if (secondsUntilEvent < 0)
        secondsUntilEvent = 0;

    String duration = formatDurationMMSS(durationSec);
    String timeToEvent = formatDurationHHMM(secondsUntilEvent);
    TrackedSatInfo[satIndex].passDuration = duration;
    TrackedSatInfo[satIndex].timeToEvent = timeToEvent;
    if (satCurrentlyVisible)
{
    strncpy(TrackedSatInfo[satIndex].nextEventType, "LOS", sizeof(TrackedSatInfo[satIndex].nextEventType));
}
else
{
    strncpy(TrackedSatInfo[satIndex].nextEventType, "AOS", sizeof(TrackedSatInfo[satIndex].nextEventType));
}

    TrackedSatInfo[satIndex].aosUTC = pass.jdstart;
    TrackedSatInfo[satIndex].tcaUTC = pass.jdmax;
    TrackedSatInfo[satIndex].losUTC = pass.jdstop;
    TrackedSatInfo[satIndex].maxElevation = pass.maxelevation;

    // Step 7: Print results
    /*
    Serial.println();
    Serial.println("üì° Next Pass Times (local / UTC):");
    Serial.printf("AOS : %s local / %s UTC  az=%.1f¬∞\n", aosLocal.c_str(), aosUTC.c_str(), pass.azstart);
    Serial.printf("TCA : %s local / %s UTC  el=%.1f¬∞\n", tcaLocal.c_str(), tcaUTC.c_str(), pass.maxelevation);
    Serial.printf("LOS : %s local / %s UTC  az=%.1f¬∞\n", losLocal.c_str(), losUTC.c_str(), pass.azstop);
    Serial.printf("‚è±Ô∏è  Duration     : %s\n", duration.c_str());

    if (satCurrentlyVisible)
    {
        Serial.printf("‚è≥ Until LOS    : %s\n", timeToEvent.c_str());
    }
    else
    {
        Serial.printf("‚è≥ Until AOS    : %s\n", timeToEvent.c_str());
    }
    */
    TrackedSatInfo[satIndex].azAtAOS = pass.azstart;
    TrackedSatInfo[satIndex].azAtLOS = pass.azstop;
    return true;
}

/**
 * üõ∞Ô∏è loadAndTrackSatelliteByCatalogNumber()
 *
 * Loads TLE data for a specific satellite, calculates its current position,
 * applies Doppler correction, and updates the `TrackedSatInfo` array.
 * Optionally broadcasts the satellite data over WebSocket.
 *
 * Parameters:
 *   catalogNumber   - NORAD catalog number of the satellite to track
 *   shouldBroadcast - whether to broadcast the satellite data via WebSocket
 *
 * Notes:
 * - Uses TLE data from Preferences (or RAM cache if you've optimized it).
 * - Applies manual tzOffset (seconds) to display local time.
 */
void loadAndTrackSatelliteByCatalogNumber(int catalogNumber, bool shouldBroadcast)
{
    // üîÅ Load TLE from cache or Preferences
    String name = "", l1 = "", l2 = "";
    for (int i = 0; i < numSatellitesToTrack; ++i)
    {
        if (satellitesToTrack[i] == catalogNumber)
        {
            name = TLECache[i].name;
            l1 = TLECache[i].tle1;
            l2 = TLECache[i].tle2;
            break;
        }
    }

    if (name == "" || l1 == "" || l2 == "")
    {
        Serial.printf("‚ùå TLE missing for CATNR %d\n", catalogNumber);
        return;
    }

    char nameBuf[64], l1Buf[130], l2Buf[130];
    strncpy(nameBuf, name.c_str(), sizeof(nameBuf));
    nameBuf[63] = '\0';
    strncpy(l1Buf, l1.c_str(), sizeof(l1Buf));
    l1Buf[129] = '\0';
    strncpy(l2Buf, l2.c_str(), sizeof(l2Buf));
    l2Buf[129] = '\0';

    // üõ∞Ô∏è Initialize satellite with site location and TLE
    sat.site(OBSERVER_LATITUDE, OBSERVER_LONGITUDE, OBSERVER_ALTITUDE);
    sat.init(nameBuf, l1Buf, l2Buf);
    sat.findsat((unsigned long)time(nullptr));

    // üÜî Find index of satellite in tracking array
    int satIndex = -1;
    for (int i = 0; i < numSatellitesToTrack; i++)
    {
        if (satellitesToTrack[i] == catalogNumber)
        {
            satIndex = i;
            break;
        }
    }

    // üõ∏ Estimate radial velocity (for Doppler)
    float radialVelocity = 0.0;
    unsigned long nowMillis = millis();
    if (satIndex >= 0 && previousTime[satIndex] > 0)
    {
        float dt = (nowMillis - previousTime[satIndex]) / 1000.0;
        if (dt > 0.1)
        {
            radialVelocity = (sat.satDist - previousDist[satIndex]) / dt;
        }
    }
    if (satIndex >= 0)
    {
        previousDist[satIndex] = sat.satDist;
        previousTime[satIndex] = nowMillis;
    }

    // üì° Get nominal downlink frequency (MHz)
    float nominalFreqMHz = 0.0;
    for (int i = 0; i < sizeof(satellites) / sizeof(satellites[0]); ++i)
    {
        if (satellites[i].catalogNumber == catalogNumber)
        {
            nominalFreqMHz = satellites[i].downlinkFreqMHz;
            break;
        }
    }

    float correctedHz = nominalFreqMHz * 1e6;
    if (nominalFreqMHz > 0.0)
    {
        correctedHz *= (1 - radialVelocity / 299792.458); // Doppler shift
    }

    // üñ®Ô∏è Print satellite position info
    Serial.printf("\nüõ∞Ô∏è  %s\n", nameBuf);

    int y, m, d, h, min;
    double sec;

    invjday(sat.satJd, 0, false, y, m, d, h, min, sec); // UTC
    Serial.printf("üìÖ UTC Time   : %02d/%02d/%04d %02d:%02d:%02.0f\n", d, m, y, h, min, sec);

    invjday(sat.satJd, tzOffset / 3600, false, y, m, d, h, min, sec); // Local
    
    /*
    Serial.printf("üìÖ Local Time : %02d/%02d/%04d %02d:%02d:%02.0f\n", d, m, y, h, min, sec);
    Serial.printf("üì° Az: %.1f¬∞, El: %.1f¬∞, Dist: %.1f km\n", sat.satAz, sat.satEl, sat.satDist);
    Serial.printf("üåç Lat: %.4f¬∞, Lon: %.4f¬∞, Alt: %.1f km\n", sat.satLat, sat.satLon, sat.satAlt);
    Serial.printf("üöÄ Radial velocity ‚âà %.3f km/s\n", radialVelocity);
    Serial.printf("üìª Nominal frequency: %.3f MHz\n", nominalFreqMHz);
    Serial.printf("üìª Corrected frequency: %.6f MHz\n", correctedHz / 1e6);
    Serial.printf("üìª Doppler shift: %+6.0f Hz\n", correctedHz - nominalFreqMHz * 1e6);
    Serial.printf("üîÅ Setting GQRX with  freq: %.3f MHz\n", correctedHz);
    */
    
    

    // üåê Send WebSocket message if requested
    if (shouldBroadcast)
    {
        char msg[160];
        snprintf(msg, sizeof(msg),
                 "{\"name\":\"%s\",\"az\":%.1f,\"el\":%.1f,\"freq\":%.6f,"
                 "\"azAOS\":%.1f,\"azLOS\":%.1f}",
                 nameBuf,
                 sat.satAz,
                 sat.satEl,
                 correctedHz / 1e6,
                 TrackedSatInfo[satIndex].azAtAOS,
                 TrackedSatInfo[satIndex].azAtLOS);
        webSocket.broadcastTXT(msg);
        AzimuthForRotator = sat.satAz;
        ElevationForRotator = sat.satEl;
        Serial.println("üì§ WebSocket sent: " + String(msg));
        sendFreqToGQRX(correctedHz / 1e6);
    }

    // üß† Update global info array
    if (satIndex >= 0)
    {
        SatelliteInfo &info = TrackedSatInfo[satIndex];
        strncpy(info.name, nameBuf, sizeof(info.name));
        info.name[sizeof(info.name) - 1] = '\0';

        info.azimuth = sat.satAz;
        info.elevation = sat.satEl;
        info.distance = sat.satDist;
        info.frequencyMHz = nominalFreqMHz;
        info.correctedFreqMHz = correctedHz / 1e6;
        info.dopplerHz = correctedHz - nominalFreqMHz * 1e6;
    }

    // üõ∞Ô∏è Predict and store next pass info (calls predictNextPass)
    predictNextPass(catalogNumber);
}

/**
 * üõ∞Ô∏è trackConfiguredSatellites()
 *
 * Loops through all configured satellites and updates their real-time tracking data.
 * - Calls `loadAndTrackSatelliteByCatalogNumber()` for each satellite.
 * - Enables WebSocket broadcast only for the currently tracked satellite (based on `trackedSatIndex`).
 * - Updates azimuth, elevation, distance, Doppler shift, and pass predictions.
 */

void trackConfiguredSatellites()
{

    Serial.println("üîÑ Tracking all configured satellites...");

    for (int i = 0; i < numSatellitesToTrack; ++i)
    {
        bool shouldBroadcast = false;
        if (currentTrackingTarget == String(TrackedSatInfo[i].name))
        {
            if (trackingEnabled == true)
            {
                shouldBroadcast = true;
            }
        }
        loadAndTrackSatelliteByCatalogNumber(satellitesToTrack[i], shouldBroadcast);
    }

    if (trackingEnabled && currentTrackingTarget == "sun")
    {
        String msg = StringFormat(
            "{\"name\":\"Sun\",\"az\":%.1f,\"el\":%.1f}",
            SunMoonInfo.sunAzimuth,
            SunMoonInfo.sunElevation);
        webSocket.broadcastTXT(msg);
        Serial.println("üì§ WebSocket sent (Sun): " + msg);
        AzimuthForRotator = SunMoonInfo.sunAzimuth;
        ElevationForRotator = SunMoonInfo.sunElevation;
    }
    else if (trackingEnabled && currentTrackingTarget == "moon")
    {
        String msg = StringFormat(
            "{\"name\":\"Moon\",\"az\":%.1f,\"el\":%.1f}",
            SunMoonInfo.moonAzimuth,
            SunMoonInfo.moonElevation);
        webSocket.broadcastTXT(msg);
        Serial.println("üì§ WebSocket sent (Moon): " + msg);
        AzimuthForRotator = SunMoonInfo.moonAzimuth;
        ElevationForRotator = SunMoonInfo.moonElevation;
    }

    Serial.println("‚úÖ Satellite tracking complete.");
    // üìà Generate az/el trajectory for the current satellite pass
    // This will be served to the frontend for polar plot visualization.
    // Only applies to real satellites (not Sun/Moon).
    if (trackingEnabled && trackedSatIndex != -1 &&
        currentTrackingTarget != "sun" && currentTrackingTarget != "moon")
    {
        // Serial.println("üß™ About to call generatePassPath()");

        generatePassPath(satellitesToTrack[trackedSatIndex]);
    }
}

void controlSteppers(float azi, float ele)
{
    if (ele < 0)
    {
        ele = 0;
    }
    moveAzimuthToAngle(azi);
    moveElevationToAngle(ele);
}

/**
 * üõ∞Ô∏è isSatelliteInActivePass()
 *
 * Determines whether the satellite is currently in an active pass.
 *
 * - Compares current Julian Date to the satellite's AOS and LOS times.
 * - Returns true if the current time is between AOS and LOS.
 * - Used to decide whether to generate a polar path for a current or upcoming pass.
 *
 * Parameters:
 *   info - a SatelliteInfo struct containing AOS and LOS data
 *
 * Returns:
 *   true  ‚Üí satellite is currently above the horizon (active pass)
 *   false ‚Üí satellite is not visible (awaiting next pass)
 */
bool isSatelliteInActivePass(const SatelliteInfo &info)
{
    double nowJD = getJulianDate(); // Get current Julian Date (UTC)
    return (nowJD >= info.aosUTC) && (nowJD <= info.losUTC);
}

/**
 * üìà generatePassPath()
 *
 * Precomputes the azimuth and elevation points of a satellite pass.
 * - Called after `predictNextPass()` identifies a valid pass.
 * - Steps through the pass from AOS to LOS in 15-second intervals.
 * - Uses SGP4 to calculate the az/el for each step.
 * - Stores results in the `passPath[]` array, up to `MAX_PASS_POINTS`.
 *
 * Parameters:
 *   catalogNumber - NORAD Catalog Number of the satellite
 *
 * Notes:
 * - The generated data can be used to render a full polar trajectory
 *   (before the pass begins) in the web interface.
 * - Only points with elevation >= 0¬∞ are included.
 */
void generatePassPath(int catalogNumber)
{
    numPassPoints = 0;

    int satIndex = -1;
    for (int i = 0; i < numSatellitesToTrack; i++)
    {
        if (satellitesToTrack[i] == catalogNumber)
        {
            satIndex = i;
            break;
        }
    }

    if (satIndex == -1)
        return;

    double startJD = TrackedSatInfo[satIndex].aosUTC;
    double stopJD = TrackedSatInfo[satIndex].losUTC;
    // Serial.printf("üîç AOS JD: %.8f, LOS JD: %.8f\n", startJD, stopJD);

    if (stopJD <= startJD)
        return;

    const int stepSeconds = 15;
    const double stepDays = stepSeconds / 86400.0;

    char nameBuf[64], l1Buf[130], l2Buf[130];
    strncpy(nameBuf, TLECache[satIndex].name.c_str(), sizeof(nameBuf));
    strncpy(l1Buf, TLECache[satIndex].tle1.c_str(), sizeof(l1Buf));
    strncpy(l2Buf, TLECache[satIndex].tle2.c_str(), sizeof(l2Buf));

    Sgp4 sgp;
    sgp.site(OBSERVER_LATITUDE, OBSERVER_LONGITUDE, OBSERVER_ALTITUDE);
    sgp.init(nameBuf, l1Buf, l2Buf);

    for (double jd = startJD; jd <= stopJD; jd += stepDays)
    {
        sgp.findsat(jd);
        if (sgp.satEl >= 0 && numPassPoints < MAX_PASS_POINTS)
        {
            passPath[numPassPoints].azimuth = sgp.satAz;
            passPath[numPassPoints].elevation = sgp.satEl;
            numPassPoints++;
        }
    }

    Serial.printf("üß≠ Generated %d points for pass path of %s\n", numPassPoints, nameBuf);
}


void sendCommandToGQRX(const char* cmd) {
    WiFiClient client;
    if (!client.connect(GQRX_HOST, GQRX_PORT)) {
        Serial.println("‚ùå Failed to connect to GQRX");
        return;
    }

    client.print(cmd);
    Serial.printf("üì§ Sent to GQRX: %s", cmd);

    // Wait up to 200 ms for a response
    unsigned long timeout = millis() + 200;
    while (client.available() == 0 && millis() < timeout) {
        delay(10);
    }

    while (client.available()) {
        String reply = client.readStringUntil('\n');
        Serial.printf("üì• GQRX reply: %s\n", reply.c_str());
    }

    client.stop();
}

void sendFreqToGQRX(float freqMHz) {
    String cmd = "F " + String(freqMHz * 1e6, 0) + "\n";  // Frequency in Hz
    sendCommandToGQRX(cmd.c_str());
}




void sendDefaultGQRXSettings() {
    sendCommandToGQRX("M FM\n");         // Set mode: FM
    delay(100);
    // sendCommandToGQRX("W 12500\n");  // Skip: not accepted in FM
    // sendCommandToGQRX("L -60\n");    // Skip: optional and failing
    // sendCommandToGQRX("S\n");        // Skip: usually not needed
    Serial.println("‚úÖ GQRX default settings applied.");
}
void computeFuturePassesForAllSats() {
    Serial.println("üîÆ Computing next 10 passes for each satellite...");

    unsigned long startMillis = millis();
    int totalPasses = 0;

    for (int i = 0; i < numSatellitesToTrack; i++) {
        passCount[i] = 0;

        int catnr = satellitesToTrack[i];
        String name = TLECache[i].name;
        String l1 = TLECache[i].tle1;
        String l2 = TLECache[i].tle2;

        if (name == "" || l1 == "" || l2 == "") {
            Serial.printf("‚ùå Missing TLE for %d (%s)\n", catnr, name.c_str());
            continue;
        }

        char nameBuf[64], l1Buf[130], l2Buf[130];
        strncpy(nameBuf, name.c_str(), sizeof(nameBuf));
        nameBuf[sizeof(nameBuf) - 1] = '\0';
        strncpy(l1Buf, l1.c_str(), sizeof(l1Buf));
        l1Buf[sizeof(l1Buf) - 1] = '\0';
        strncpy(l2Buf, l2.c_str(), sizeof(l2Buf));
        l2Buf[sizeof(l2Buf) - 1] = '\0';

        Sgp4 predictor;
        predictor.site(OBSERVER_LATITUDE, OBSERVER_LONGITUDE, OBSERVER_ALTITUDE);
        predictor.init(nameBuf, l1Buf, l2Buf);

        time_t now = time(nullptr);
        double jd = now / 86400.0 + 2440587.5;
        predictor.initpredpoint(jd, 0);

        for (int p = 0; p < MAX_PASSES_PER_SAT; p++) {
            passinfo pass;
            if (!predictor.nextpass(&pass, 20)) {
                Serial.printf("‚ö†Ô∏è No more passes for %s\n", nameBuf);
                break;
            }

            futurePasses[i][p].catnr = catnr;
            futurePasses[i][p].aosJD = pass.jdstart;
            futurePasses[i][p].tcaJD = pass.jdmax;
            futurePasses[i][p].losJD = pass.jdstop;
            futurePasses[i][p].maxElevation = pass.maxelevation;
            futurePasses[i][p].durationSec = (pass.jdstop - pass.jdstart) * 86400.0;
            strncpy(futurePasses[i][p].satName, nameBuf, sizeof(futurePasses[i][p].satName));
            futurePasses[i][p].satName[sizeof(futurePasses[i][p].satName) - 1] = '\0';

            passCount[i]++;
            totalPasses++;

            predictor.initpredpoint(pass.jdstop + 0.01, 0);
        }

        Serial.printf("‚úÖ %s: %d passes computed.\n", nameBuf, passCount[i]);
        delay(200);  // Slight delay between satellites (optional)
    }

    unsigned long elapsed = millis() - startMillis;
    Serial.printf("üìä Total passes computed: %d\n", totalPasses);
    Serial.printf("‚è±Ô∏è  Total time: %lu ms\n", elapsed);
}

void setup()
{
    Serial.begin(115200);
    delay(2000);
    Serial.println("Program Starting.....");
    listFilesAndPrintUsage();

    connectToWiFi();

    tzOffset = getTimeZoneOffsetFromAPI();

    synchronizeTimeWithNTP();

    printUtcAndLocalTime();

    lastNtpSync = millis();

    checkAndRefreshTLEsIfNeeded();

    loadTLEsIntoRAM();

    Serial.println("üì° Available satellites:");
    for (int i = 0; i < numSatellitesToTrack; i++) {
      int catnr = satellitesToTrack[i];
      for (int j = 0; j < sizeof(satellites) / sizeof(satellites[0]); j++) {
        if (satellites[j].catalogNumber == catnr) {
          Serial.printf("  - %s\n", satellites[j].name);
          break;
        }
      }
    }
    
    computeFuturePassesForAllSats();

    webSocket.begin();

    webSocket.onEvent([](uint8_t num, WStype_t type, uint8_t *payload, size_t length)
                      {
        if (type == WStype_CONNECTED) {
            IPAddress ip = webSocket.remoteIP(num);
            Serial.printf("‚úÖ WebSocket client [%u] connected from %s\n", num, ip.toString().c_str());
        } 
        else if (type == WStype_DISCONNECTED) {
            IPAddress ip = webSocket.remoteIP(num);
            Serial.printf("‚ùå WebSocket client [%u] disconnected from %s\n", num, ip.toString().c_str());
        } });

   
//#########################################################################################################
// ===============================
// üåê HTTP Server Routes
// ===============================

// üè† Root route: Serves the main HTML interface
server.on("/", HTTP_GET, [](AsyncWebServerRequest *request) {
    request->send(SPIFFS, "/index.html", "text/html");
});
// üéõÔ∏è Initialize GQRX with default settings (mode, filter, squelch)
server.on("/gqrx/init", HTTP_POST, [](AsyncWebServerRequest *request) {
    sendDefaultGQRXSettings();
    request->send(200, "text/plain", "GQRX initialized");
});
// üåü Favicon (optional)
server.serveStatic("/favicon.ico", SPIFFS, "/favicon.ico");


// üõ∞Ô∏è Return next 10 passes for each satellite
server.on("/futurepasses", HTTP_GET, [](AsyncWebServerRequest *request) {
    String json = "{";
    json += "\"tzOffset\":" + String(tzOffset) + ","; // e.g. 7200 for UTC+2
    json += "\"passes\":[";

    bool first = true;
    for (int i = 0; i < numSatellitesToTrack; ++i) {
        for (int j = 0; j < MAX_PASSES_PER_SAT; ++j) {
            const SatPassInfo& p = futurePasses[i][j];
            if (p.catnr == 0) continue;  // Skip unused

            if (!first) json += ",";
            first = false;

            long aosUnix = (long)((p.aosJD - 2440587.5) * 86400.0);
            long tcaUnix = (long)((p.tcaJD - 2440587.5) * 86400.0);
            long losUnix = (long)((p.losJD - 2440587.5) * 86400.0);

            json += "{";
            json += "\"name\":\"" + String(p.satName) + "\",";
            json += "\"catalogNumber\":" + String(p.catnr) + ",";
            json += "\"aosTimestamp\":" + String(aosUnix) + ",";
            json += "\"tcaTimestamp\":" + String(tcaUnix) + ",";
            json += "\"losTimestamp\":" + String(losUnix) + ",";
            json += "\"maxElevation\":" + String(p.maxElevation, 1) + ",";
            json += "\"duration\":\"" + formatDurationMMSS(p.durationSec) + "\"";
            json += "}";
        }
    }

    json += "]}";
    request->send(200, "application/json", json);
});






server.on("/future.html", HTTP_GET, [](AsyncWebServerRequest *request) {
    request->send(SPIFFS, "/future.html", "text/html");
});
// üéØ Start tracking a satellite, the sun, or the moon
server.on("/track", HTTP_POST,
    [](AsyncWebServerRequest *request) {
        request->send(200, "text/plain", "Track command received");
    },
    NULL,
    [](AsyncWebServerRequest *request, uint8_t *data, size_t len, size_t index, size_t total) {
        DynamicJsonDocument doc(256);
        DeserializationError error = deserializeJson(doc, data, len);

        if (error) {
            Serial.printf("‚ùå JSON deserialization failed: %s\n", error.c_str());
            request->send(400, "text/plain", "Invalid JSON");
            return;
        }

        const char *target = doc["target"];
        if (!target) {
            request->send(400, "text/plain", "Missing 'target'");
            return;
        }

        currentTrackingTarget = String(target);
        trackingEnabled = true;

        Serial.printf("üì© /track received ‚Äî now tracking: '%s'\n", currentTrackingTarget.c_str());

        if (currentTrackingTarget == "sun" || currentTrackingTarget == "moon") {
            trackedSatIndex = -1;
            Serial.println("üåûüåï Tracking celestial body (sun or moon).\n");
        } else {
            int index = findSatelliteIndexByName(currentTrackingTarget);
            if (index >= 0) {
                trackedSatIndex = index;
                Serial.printf("üõ∞Ô∏è Tracking satellite: %s (index %d)\n", currentTrackingTarget.c_str(), index);
            } else {
                Serial.printf("‚ö†Ô∏è Unknown tracking target: %s\n", currentTrackingTarget.c_str());
                request->send(400, "text/plain", "Unknown satellite name");
                return;
            }
        }

        request->send(200, "text/plain", "Tracking started");
    }
);

// üõë Stop tracking any satellite/sun/moon
server.on("/stop", HTTP_POST, [](AsyncWebServerRequest *request) {
    Serial.println("üõë /stop tracking requested");
    trackingEnabled = false;
    currentTrackingTarget = "";
    trackedSatIndex = -1;
    request->send(200, "text/plain", "Tracking stopped");
});

// ‚òÄÔ∏èüåï Get current sun and moon az/el and rise/set times
server.on("/sunmoon", HTTP_GET, [](AsyncWebServerRequest *request) {
    String json = "{";
    json += "\"sunAzimuth\":" + String(SunMoonInfo.sunAzimuth, 2) + ",";
    json += "\"sunElevation\":" + String(SunMoonInfo.sunElevation, 2) + ",";
    json += "\"sunRiseUTC\":\"" + formatTimeUTC(SunMoonInfo.sunRiseUTC) + "\",";
    json += "\"sunSetUTC\":\"" + formatTimeUTC(SunMoonInfo.sunSetUTC) + "\",";
    json += "\"sunRiseLocal\":\"" + formatTimeLocal(SunMoonInfo.sunRiseUTC) + "\",";
    json += "\"sunSetLocal\":\"" + formatTimeLocal(SunMoonInfo.sunSetUTC) + "\",";
    json += "\"moonAzimuth\":" + String(SunMoonInfo.moonAzimuth, 2) + ",";
    json += "\"moonElevation\":" + String(SunMoonInfo.moonElevation, 2) + ",";
    json += "\"moonRiseUTC\":\"" + formatTimeUTC(SunMoonInfo.moonRiseUTC) + "\",";
    json += "\"moonSetUTC\":\"" + formatTimeUTC(SunMoonInfo.moonSetUTC) + "\",";
    json += "\"moonRiseLocal\":\"" + formatTimeLocal(SunMoonInfo.moonRiseUTC) + "\",";
    json += "\"moonSetLocal\":\"" + formatTimeLocal(SunMoonInfo.moonSetUTC) + "\"";
    json += "}";
    request->send(200, "application/json", json);
});

// üõ∞Ô∏è List all tracked satellites with current data
server.on("/satellites", HTTP_GET, [](AsyncWebServerRequest *request) {
    String json = "[";
    for (int i = 0; i < numSatellitesToTrack; i++) {
        if (i > 0) json += ",";

        SatelliteInfo &sat = TrackedSatInfo[i];
        json += "{";
        json += "\"name\":\"" + String(sat.name) + "\",";
        json += "\"azimuth\":" + String(sat.azimuth, 1) + ",";
        json += "\"elevation\":" + String(sat.elevation, 1) + ",";
        json += "\"distance\":" + String(sat.distance, 1) + ",";
        json += "\"frequencyMHz\":" + String(sat.frequencyMHz, 3) + ",";
        json += "\"correctedFreqMHz\":" + String(sat.correctedFreqMHz, 6) + ",";
        json += "\"dopplerHz\":" + String(sat.dopplerHz, 0) + ",";
        json += "\"aosUTC\":\"" + formatTimeStampFromJD(sat.aosUTC, 0) + "\",";
        json += "\"aosLocal\":\"" + formatTimeStampFromJD(sat.aosUTC, tzOffset / 3600) + "\",";
        json += "\"tcaUTC\":\"" + formatTimeStampFromJD(sat.tcaUTC, 0) + "\",";
        json += "\"tcaLocal\":\"" + formatTimeStampFromJD(sat.tcaUTC, tzOffset / 3600) + "\",";
        json += "\"losUTC\":\"" + formatTimeStampFromJD(sat.losUTC, 0) + "\",";
        json += "\"losLocal\":\"" + formatTimeStampFromJD(sat.losUTC, tzOffset / 3600) + "\",";
        json += "\"maxElevation\":" + String(sat.maxElevation, 1) + ",";
        json += "\"passDuration\":\"" + sat.passDuration + "\",";
        json += "\"timeToEvent\":\"" + sat.timeToEvent + "\",";
        json += "\"nextEvent\":\"" + String(sat.nextEventType) + "\"";
        json += "}";
    }
    json += "]";
    request->send(200, "application/json", json);
});

// üåç Return observer position and API key (for frontend maps)
server.on("/observer", HTTP_GET, [](AsyncWebServerRequest *request) {
    String json = "{";
    json += "\"latitude\":" + String(OBSERVER_LATITUDE, 7) + ",";
    json += "\"longitude\":" + String(OBSERVER_LONGITUDE, 7) + ",";
    json += "\"altitude\":" + String(OBSERVER_ALTITUDE, 1) + ",";
    json += "\"mapsApiKey\":\"" + String(GOOGLE_MAPS_API_KEY) + "\"";
    json += "}";
    request->send(200, "application/json", json);
});

// üì° Return precomputed satellite pass trajectory (az/el points)
server.on("/passpath", HTTP_GET, [](AsyncWebServerRequest *request) {
    if (currentTrackingTarget == "" || currentTrackingTarget == "sun" || currentTrackingTarget == "moon") {
        request->send(400, "application/json", "{\"error\":\"No satellite is currently tracked\"}");
        return;
    }

    int index = findSatelliteIndexByName(currentTrackingTarget);
    if (index < 0) {
        request->send(400, "application/json", "{\"error\":\"Tracked satellite not found\"}");
        return;
    }

    // Recalculate path right before serving (ensures freshness)
    generatePassPath(satellitesToTrack[index]);

    String json = "[";
    for (int i = 0; i < numPassPoints; i++) {
        if (i > 0) json += ",";
        json += "{";
        json += "\"az\":" + String(passPath[i].azimuth, 1) + ",";
        json += "\"el\":" + String(passPath[i].elevation, 1);
        json += "}";
    }
    json += "]";
    request->send(200, "application/json", json);
});

server.on("/current", HTTP_GET, [](AsyncWebServerRequest *request) {
    String json = "{";
    json += "\"name\":\"" + currentTrackingTarget + "\",";
    json += "\"enabled\":" + String(trackingEnabled ? "true" : "false");
    json += "}";
    request->send(200, "application/json", json);
});


//#########################################################################################################



    server.begin(); // ‚úÖ Start the Async Web Server

    Serial.println("üåê Async Web server started!");
    Serial.print("üì° Connect your browser to: http://");
    Serial.println(WiFi.localIP());
    Serial.print("   Or use the hostname: ");
    Serial.print(DEVICE_HOSTNAME);
    Serial.println(".local");

    // Satrotator section
    // Configure output pins
    pinMode(ELE_EN_PIN, OUTPUT);
    pinMode(AZI_EN_PIN, OUTPUT);
    pinMode(STATUS_LED_PIN, OUTPUT);

    // Disable motor drivers initially (HIGH = disabled for most drivers)
    digitalWrite(ELE_EN_PIN, HIGH);
    digitalWrite(AZI_EN_PIN, HIGH);

    // Turn OFF status LED initially
    digitalWrite(STATUS_LED_PIN, LOW);

    // Configure optocoupler input pins (with internal pull-up resistors)
    pinMode(AZIoptocouplerSensor, INPUT_PULLUP);
    pinMode(ELEoptocouplerSensor, INPUT_PULLUP);

    // Configure AccelStepper parameters for AZI and ELE
    eleStepper.setMaxSpeed(1200);     // Steps per second
    eleStepper.setAcceleration(400);  // Steps per second squared
    eleStepper.setCurrentPosition(0); // Reset position to zero

    aziStepper.setMaxSpeed(1200);
    aziStepper.setAcceleration(400);
    aziStepper.setCurrentPosition(0);
    // Perform parking and testing sequence
    // parkAzimuth();
    // parkElevation();
    // testParallelMove();
}

void loop()
{
    webSocket.loop();
    unsigned long currentMillis = millis();

    // ‚è∞ Periodic NTP resync
    if (currentMillis - lastNtpSync > 3600000) // 1 hour
    {
        synchronizeTimeWithNTP();
        lastNtpSync = millis();
    }

    // üì° Periodic TLE check
    if (currentMillis - lastTLECheck > 60000) // 1 minute
    {
        checkAndRefreshTLEsIfNeeded();
        lastTLECheck = millis();
    }

    // üåûüåï‚òÄÔ∏è Sun + Moon updates every 5s + satellite tracking logic
    if (currentMillis - lastTrackTime > 1000)
    {
        double az, el, rise, set;

        // üåû SUN
        getSunAzElAndRiseSet(az, el, rise, set);
        SunMoonInfo.sunAzimuth = az;
        SunMoonInfo.sunElevation = el;
        SunMoonInfo.sunRiseUTC = rise;
        SunMoonInfo.sunSetUTC = set;

        // üåï MOON
        getMoonAzElAndRiseSet(az, el, rise, set);
        SunMoonInfo.moonAzimuth = az;
        SunMoonInfo.moonElevation = el;
        SunMoonInfo.moonRiseUTC = rise;
        SunMoonInfo.moonSetUTC = set;

        // üõ∞Ô∏è Satellite predictions
        trackConfiguredSatellites();

        lastTrackTime = currentMillis;

        controlSteppers(AzimuthForRotator, ElevationForRotator);
    }

    // üîÅ Rotor feedback every N ms
    if (millis() - lastRotorUpdate > rotorUpdateInterval)
    {
        lastRotorUpdate = millis();
        Serial.println("üü° Sending rotor position over WebSocket...");

        float azDeg = aziStepper.currentPosition() * AZI_DEG_PER_STEP;
        float elDeg = eleStepper.currentPosition() * ELE_DEG_PER_STEP;

        String json = "{";
        json += "\"type\":\"rotor\",";
        json += "\"azi\":" + String(azDeg, 1) + ",";
        json += "\"ele\":" + String(elDeg, 1);
        json += "}";

        webSocket.broadcastTXT(json);
    }

    // üì° Real tracking broadcast every 2s
    static unsigned long lastTrackingBroadcast = 0;
    if (millis() - lastTrackingBroadcast > 5000)
    {
        lastTrackingBroadcast = millis();

        if (currentTrackingTarget == "")
        {
            // Nothing to track
            return;
        }

        if (currentTrackingTarget == "sun")
        {
            webSocket.broadcastTXT(
                String("{\"name\":\"sun\",\"az\":") + SunMoonInfo.sunAzimuth +
                ",\"el\":" + SunMoonInfo.sunElevation + "}");
        }
        else if (currentTrackingTarget == "moon")
        {
            webSocket.broadcastTXT(
                String("{\"name\":\"moon\",\"az\":") + SunMoonInfo.moonAzimuth +
                ",\"el\":" + SunMoonInfo.moonElevation + "}");
        }
        else
        {
            int index = findSatelliteIndexByName(currentTrackingTarget);
            if (index >= 0)
            {
                SatelliteInfo &sat = TrackedSatInfo[index];
                webSocket.broadcastTXT(
                    String("{\"name\":\"") + sat.name + "\",\"az\":" +
                    sat.azimuth + ",\"el\":" + sat.elevation + "}");
            }
            else
            {
                Serial.println("‚ö†Ô∏è No satellite match found for: " + currentTrackingTarget);
            }
        }
    }



    static unsigned long lastTest = 0;
    if (millis() - lastTest > 3000000000) {
        lastTest = millis();
    
        // üéØ Generate random frequency: 144.0 to 146.0 MHz
        float testFreq = 144.0 + (rand() % 2000) / 1000.0;  // 144.000 - 145.999
        Serial.printf("üîÅ Testing GQRX with random freq: %.3f MHz\n", testFreq);
        sendFreqToGQRX(testFreq);
        sendDefaultGQRXSettings();
    }



}
